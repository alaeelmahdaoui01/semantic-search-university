Algorithmic Foundations : Graph Algorithms Omar Saadi omar.saadi@um6p.ma UM6P - College of Computing 1st year of the engineering degree of UM6P-CS Academic year 2024-2025 Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 1 / 28 Why Graphs ? Graphs have applications in many areas, including : Social networks, air networks, road networks, energy networks (electricity, gas, water,...) Mathematics : graphs are useful is many areas of mathematics (geometry, dynamic systems, operations research,...) Computer science : links between web pages, networks of communication, data organization, map networks, ... Statistical physics (interactions between parts of a system), study of molecules, ... Some of the objectives of the course : Understand the structure of graphs Learn the techniques used to analyze problems in graph theory Learn algorithms on trees and graphs Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 2 / 28 Chapter 1 : Fundamental concepts about graphs 1 Definition of a graph 2 Graphs as models 3 Matrix representation and isomorphism 4 Decomposition and Special graphs Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 3 / 28 Definition of a graph Outline 1 Definition of a graph 2 Graphs as models 3 Matrix representation and isomorphism 4 Decomposition and Special graphs Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 4 / 28 Definition of a graph The K¨ onigsberg Bridge Problem The city of K¨ onigsberg was located on the Pregel river in Prussia which divides it into four regions. These regions are connected together using seven bridges, as shown in the following drawing : Citizens wondered if they could take a walk in the city while crossing each bridge exactly once. The resolution of this problem was given by Leonhard Euler in 1736. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 5 / 28 Definition of a graph The K¨ onigsberg Bridge Problem To simplify this problem, we reduce the drawing to the following diagram : a b c d e1 e2 e3 e4 e5 e6 e7 The four regions are represented by vertices and the seven bridges by edges. Answer : Such walk is not possible. Proof : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 6 / 28 Definition of a graph Definition A graph G is a triple consisting of a vertex setV (G), an edge setE(G), and a
the seven bridges by edges. Answer : Such walk is not possible. Proof : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 6 / 28 Definition of a graph Definition A graph G is a triple consisting of a vertex setV (G), an edge setE(G), and a relation that associates with each edge two vertices (not necessarily distinct) called its endpoints. Example In the graph showed above, the vertex set is {a, b, c, d}, the edge set is {e1, e2, e3, e4, e5, e6, e7}, and the assignment of endpoints to edges can be read from the diagram. Definition A loop is an edge whose endpoints are equal. Multiple edgesare edges having the same pair of endpoints. a a b Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 7 / 28 Definition of a graph Definition A simple graphis a graph without loops and multiple edges. A graph is loopless means that multiple edges are allowed but loops are not. Example The graph of the K¨ onigsberg bridge problem is loopless but it is not simple. Remark We specify a simple graph G by its vertex set V (G) and edge set E(G). The edge set is treated as a set of unordered pairs of vertices. We write e = uv (or e = vu) for an edge e with endpoints u and v. Definition We say that the vertices u and v are adjacent (or neighbors) if they are the endpoints of the same edge. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 8 / 28 Definition of a graph Example The two following drawings show the same simple graph. The vertex set is {a, b, c, d, e} and the edge set is {ab, ac, ad, bc, bd, cd, de } : a bc d e a b c d e Remark The terms ”vertex” and ”edge” arise from solid geometry. For example the following 3-d cube has vertices linked by edges. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 9 / 28 Graphs as models Outline 1 Definition of a graph 2 Graphs as models 3 Matrix representation and isomorphism 4 Decomposition and Special graphs Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 10 / 28 Graphs as models Acquaintance relations and subgraphs Question Does every set of six people contain
models Outline 1 Definition of a graph 2 Graphs as models 3 Matrix representation and isomorphism 4 Decomposition and Special graphs Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 10 / 28 Graphs as models Acquaintance relations and subgraphs Question Does every set of six people contain three mutual acquaintances or three mutual strangers ? We can model this problem using a simple graph with a vertex for each person and an edge for each acquainted pair. Note that the “nonacquaintance” relation yields another graph with the “complementary” set of edges. Definition The complement ¯G of a simple graph G is the simple graph with vertex set V (G) defined by uv ∈ E( ¯G) if and only if uv ̸∈ E(G). A clique in a graph is a set of pairwise adjacent vertices. An independent set (or stable set) in a graph is a set of pairwise nonadjacent vertices. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 11 / 28 Graphs as models In the graph G, {u, x, y} is a clique of size 3 and {u, w} is an independent set of size 2, and these are the largest such sets. Remark In the complement graph ¯G, cliques become independent sets, and independent sets become cliques. Reformulation of the above question :Is it true that every 6-vertex graph has a clique of size 3 or an independent set of size 3 ? Answer :(As exercice) Notice that by deleting the edge ux from the above graph G, we get a 5-vertex graph having no clique or independent set of size 3. So the answer is no for 5-vertex graphs. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 12 / 28 Graphs as models Job assignments and bipartite graphs Question We have m jobs, and n people, but not all people are qualified for all jobs. Can we fill the jobs with qualified people ? We model this using a simple graph G with vertices for the jobs and people ; job j is adjacent to person p if p can do j. So the question is to find m pairwise disjoint edges in G. Definition A graph G is bipartite if V (G) is the union of two disjoint independent sets called partite setsof G. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 13 /
p can do j. So the question is to find m pairwise disjoint edges in G. Definition A graph G is bipartite if V (G) is the union of two disjoint independent sets called partite setsof G. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 13 / 28 Graphs as models Scheduling and graph coloring Question Suppose we must schedule Parliament committee meetings into designated weekly time periods. We cannot assign two committees to the same time if they have a common member. How many different time periods do we need ? Modeling : We create a vertex for each committee, with two vertices adjacent when the two committees have a common member. We must assign labels (time periods) to the vertices such that adjacent vertices receive different labels. Example : We can use one color (label) for each of the three independent sets. The members of a clique must receive distinct labels ⇒ the minimum number of colors (time periods) is three. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 14 / 28 Graphs as models Scheduling and graph coloring Question Suppose we must schedule Parliament committee meetings into designated weekly time periods. We cannot assign two committees to the same time if they have a common member. How many different time periods do we need ? Modeling : We create a vertex for each committee, with two vertices adjacent when the two committees have a common member. We must assign labels (time periods) to the vertices such that adjacent vertices receive different labels. Example : We can use one color (label) for each of the three independent sets. The members of a clique must receive distinct labels ⇒ the minimum number of colors (time periods) is three. Example : We can use one color (label) for each of the three independent sets. The members of a clique must receive distinct labels ⇒ the minimum number of colors (time periods) is three. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 14 / 28 Graphs as models Scheduling and graph coloring Question Suppose we must schedule Parliament committee meetings into designated weekly time periods. We cannot assign two committees to the same time if they have a common member. How many different time periods do we need ? Modeling : We create a vertex for each committee, with two vertices adjacent
Question Suppose we must schedule Parliament committee meetings into designated weekly time periods. We cannot assign two committees to the same time if they have a common member. How many different time periods do we need ? Modeling : We create a vertex for each committee, with two vertices adjacent when the two committees have a common member. We must assign labels (time periods) to the vertices such that adjacent vertices receive different labels. Example : We can use one color (label) for each of the three independent sets. The members of a clique must receive distinct labels ⇒ the minimum number of colors (time periods) is three. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 14 / 28 Graphs as models Definition A coloring of a graph is an assignment of a color to each vertex such that adjacent vertices receive different colors. The chromatic number of a graph G, written χ(G), is the minimum number of colors needed to color G. A graph G is k-partite if V (G) can be expressed as the union of k (possibly empty) independent sets. So the above question is asking about the chromatic number of the graph and the corresponding coloring. Remark The k-partite notion generalizes the idea of bipartite graphs, which are 2-partite. A graph is k-partite if and only if its chromatic number is at most k. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 15 / 28 Graphs as models Routes in road networks Modeling : We can model a road network using a graph where : Vertices are intersections, Edges are road segments between intersections, We can assign edge weights to measure distance or travel time. Question How can we find the shortest route from a point x to a point y ? Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 16 / 28 Graphs as models Definition A path is a simple graph whose vertices can be ordered so that two vertices are adjacent if and only if they are consecutive in the list. A cycle is a graph with an equal number of vertices and edges whose vertices can be placed around a circle so that two vertices are adjacent if and only if they appear consecutively along the circle. Example : a path a cycle Definition A subgraph of a graph G is a graph
a graph with an equal number of vertices and edges whose vertices can be placed around a circle so that two vertices are adjacent if and only if they appear consecutively along the circle. Example : a path a cycle Definition A subgraph of a graph G is a graph H such that V (H) ⊂ V (G) and E(H) ⊂ E(G) and the assignment of endpoints to edges in H is the same as in G. We write H ⊂ G and say that “ G contains H”. A graph G is connected if each pair of vertices in G is connected by a path ; otherwise, G is disconnected. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 17 / 28 Matrix representation and isomorphism Outline 1 Definition of a graph 2 Graphs as models 3 Matrix representation and isomorphism 4 Decomposition and Special graphs Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 18 / 28 Matrix representation and isomorphism Matrix representation Definition Let G be a loopless graph with vertex set V (G) = {v1, . . . ,vn} and edge set E(G) = {e1, ··· , em}. The adjacency matrixof G, written A(G), is the n-by-n matrix in which entry aij is the number of edges in G with endpoints {vi , vj }. The incidence matrixM(G) is the n-by-m matrix in which entry mij is 1 if vi is an endpoint of ej and otherwise is 0. Example : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 19 / 28 Matrix representation and isomorphism Definition If vertex v is an endpoint of edge e, we say that v and e are incident. The degree of vertex v (in a loopless graph) is the number of incident edges to v. We denote the degree of v by deg(v). Remark An adjacency matrix is determined by a vertex ordering. Every adjacency matrix is symmetric ( aij = aji for all i, j). An adjacency matrix of a simple graph G has entries 0 or 1, with 0s on the diagonal. The degree of v is the sum of the entries in the row for v in either A(G) or M(G). Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 20 / 28 Matrix representation and isomorphism Graph isomorphism Definition An isomorphism from a simple graph G to
diagonal. The degree of v is the sum of the entries in the row for v in either A(G) or M(G). Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 20 / 28 Matrix representation and isomorphism Graph isomorphism Definition An isomorphism from a simple graph G to a simple graph H is a bijection f : V (G) → V (H) such that uv ∈ E(G) if and only if f (u)f (v) ∈ E(H). We say “G is-isomorphic to H”, written G ∼= H, if there is an isomorphism from G to H. Example : The following graphs G and H are isomorphic : Proposition The isomorphism relation is an equivalence relation on the set of (simple) graphs. Proof : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 21 / 28 Matrix representation and isomorphism Recall An equivalence relation partitions a set into equivalence classes ; two elements satisfy the relation if and only if they lie in the same class. Definition An isomorphism classof graphs is an equivalence class of graphs under the isomorphism relation. We use the expression “unlabeled graph” to mean an isomorphism class of graphs. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 22 / 28 Matrix representation and isomorphism Definition The (unlabeled) path and cycle with n vertices are denoted Pn and Cn, respectively. A complete graphis a simple graph whose vertices are pairwise adjacent ; the (unlabeled) complete graph with n vertices is denoted Kn. A complete bipartite graph(or biclique) is a simple bipartite graph such that two vertices are adjacent if and only if they are in different partite sets. When the sets have sizes r and s, the (unlabeled) biclique is denoted Kr,s . Example : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 23 / 28 Decomposition and Special graphs Outline 1 Definition of a graph 2 Graphs as models 3 Matrix representation and isomorphism 4 Decomposition and Special graphs Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 24 / 28 Decomposition and Special graphs Decomposition of graphs Definition A decomposition of a graph is a list of subgraphs such that each edge appears in exactly one subgraph in the list. Definition and Remark A graph is self-complementary if it is isomorphic to its complement. An n-vertex graph H is self-complementary if and only if
Decomposition of graphs Definition A decomposition of a graph is a list of subgraphs such that each edge appears in exactly one subgraph in the list. Definition and Remark A graph is self-complementary if it is isomorphic to its complement. An n-vertex graph H is self-complementary if and only if Kn has a decomposition consisting of two copies of H. Example : We can decompose K5 into two 5-cycles, and thus the 5-cycle is self-complementary (left figure). We can decompose K4 using three copies of P3 (right figure). Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 25 / 28 Decomposition and Special graphs Petersen graph Definition The Petersen graphis the simple graph whose vertices are the 2-element subsets of a 5-element set and whose edges are the pairs of disjoint 2-element subsets. Here, we take [5] = {1, 2, 3, 4, 5} as our 5-element set, we write the pair {a, b} as ab or ba. In the following figure, we have three ways to draw the Petersen graph : The Petersen graph consists of two disjoint 5-cycles plus edges that pair up vertices on the two 5-cycles. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 26 / 28 Decomposition and Special graphs Proposition If two vertices are nonadjacent in the Petersen graph, then they have exactly one common neighbor. Proof : Definition The girth of a graph with a cycle is the length of its shortest cycle. A graph with no cycle has an infinite girth. Lemma The girth of the Petersen graph is equal to5. Proof : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 27 / 28 Decomposition and Special graphs Book references Introduction to graph theory [2nded], by Douglas B. West (2001) : (See Sect 1 .1 of West’s book for more details on our chapter 1.) Algorithms on trees and graphs [2nded], by Gabriel Valiente (2021) : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 28 / 28
Chapter 2 : Paths and Cycles Omar Saadi omar.saadi@um6p.ma UM6P - College of Computing 1st year of the engineering degree of UM6P-CS Academic year 2024-2025 Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 1 / 27 Outline 1 Connection in graphs 2 Cycles and bipartite graphs 3 Eulerian circuits 4 Hamiltonian Cycles More details on this chapter can be found in Sect 1.2 and Sect 7.2 of D. B. West’s book. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 2 / 27 Connection in graphs Outline 1 Connection in graphs 2 Cycles and bipartite graphs 3 Eulerian circuits 4 Hamiltonian Cycles Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 3 / 27 Connection in graphs Recall A path is a simple graph whose vertices can be ordered so that two vertices are adjacent if and only if they are consecutive in the list. A cycle is a graph with an equal number of vertices and edges whose vertices can be placed around a circle so that two vertices are adjacent if and only if they appear consecutively along the circle. Note that a path in a graph G is a subgraph of G that is a path (similarly for cycles). Definition A walk is a list v0, e1, v1, . . . ,ek , vk of vertices and edges such that, for 1 < i < k, the edge ei has endpoints vi−1 and vi . A trail is a walk with no repeated edge. A u, v-walk or u, v-trail has first vertex u and last vertex v ; these are its endpoints. A u, v-path is a path whose vertices of degree 1 (its endpoints) are u and v ; the others are internal vertices. The length of a walk, trail, path, or cycle is its number of edges. A walk or trail is closed if its endpoints are the same. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 4 / 27 Connection in graphs Example : In the K¨ onigsberg graph : a b c d e1 e2 e3 e4 e5 e6 e7 the list b, e4, c, e2, a, e1, b, e5, c, e4, b is a closed walk of length 5 ; it repeats edge e4 and hence is not a trail. If we delete the last edge and vertex e4, b, we
d e1 e2 e3 e4 e5 e6 e7 the list b, e4, c, e2, a, e1, b, e5, c, e4, b is a closed walk of length 5 ; it repeats edge e4 and hence is not a trail. If we delete the last edge and vertex e4, b, we obtain trail. The list a, e1, b, e4, c, e7, d is a a, d-path, and d, e6, c, e2, a, e3, d is a cycle. Remark : In a simple graph, a walk (or trail) is completely specified by its ordered list of vertices. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 5 / 27 Connection in graphs Lemma Every u, v-walk contains a u, v-path. Proof : by induction on the length l of a u, v-walk. Definition A graph G is connected if for all u, v ∈ V (G), there exists u, v-path in G (otherwise, G is disconnected). If G has a u, v-path, then u is connected to v in G. The connection relation on V (G) consists of the ordered pairs ( u, v) such that u is connected to v. Remark We recall the distinction between “adjacent” and “connected” vertices : Vertices u and v are adjacent if and only if uv ∈ E(G). Vertices u and v are connected if and only if G contains a u, v-path. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 6 / 27 Connection in graphs Remark Using the previous lemma, a way to prove that a graph is connected is by fixing a particular vertex v∗ and showing that from each vertex u ∈ V (G) there is a walk to that particular vertex v∗. Proposition The connection relation is an equivalence relation. Proof : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 7 / 27 Connection in graphs Components of a graph Definition A maximal connected subgraph of G is a subgraph that is connected and that is not contained in any other connected subgraph of G. The components of a graph G are its maximal connected subgraphs. A component (or graph) is trivial if it has no edges ; otherwise it is nontrivial. An isolated vertex is a vertex of degree 0. Remark The equivalence classes of the connection relation on V (G) are the vertex sets of the components of G. An
its maximal connected subgraphs. A component (or graph) is trivial if it has no edges ; otherwise it is nontrivial. An isolated vertex is a vertex of degree 0. Remark The equivalence classes of the connection relation on V (G) are the vertex sets of the components of G. An isolated vertex forms a trivial component, consisting of one vertex and no edge. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 8 / 27 Connection in graphs Example In the following graph : we have four components. The vertex sets of these components are {p}, {q, r}, {s, t, u, v, w}, and {x, y, z}; these are the equivalence classes of the connection relation. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 9 / 27 Connection in graphs Remark Components are pairwise disjoint ; no two share a vertex. Adding an edge with endpoints in distinct components combines them into one component. Thus, adding an edge decreases the number of components by 0 or 1, Deleting an edge increases the number of components by 0 or 1. Proposition Every graph with n vertices and k edges has at least n − k components. Proof : Remark Deleting a vertex (and also all edges incident to it, to still have a graph) can increase the number of components by many. Consider the example of the K1,m, where deleting the vertex corresponding to the partite set with one vertex increases the number of components from 1 to m. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 10 / 27 Connection in graphs Cut-deges and cut-vertices Definition A cut-edge or cut-vertex of a graph is an edge or vertex whose deletion increases the number of components. We write G − e or G − M for the subgraph of G obtained by deleting an edge e or set of edges M. Similarly, we write G − v or G − S for the subgraph obtained by deleting a vertex v or set of vertices S. An induced subgraph is a subgraph obtained by deleting a set of vertices. We write G[T ] for G − ¯T , where ¯T = V (G) − T ; this is the subgraph of G induced by T . Note that when T ⊂ V (G), the induced subgraph G[T ] consists of T and all edges
deleting a set of vertices. We write G[T ] for G − ¯T , where ¯T = V (G) − T ; this is the subgraph of G induced by T . Note that when T ⊂ V (G), the induced subgraph G[T ] consists of T and all edges whose endpoints are contained in T. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 11 / 27 Connection in graphs Example : We consider the same above graph : It has cut-vertices v and y. Its cut-edges are qr, vw, xy, and yz. This graph has C4 [ (t, s, u, v) ] and P5 [ {t, s, u, v, w} ] as subgraphs but not as induced subgraphs. The graph P4 is an induced subgraph ; it is the subgraph induced by {s, t, v, w}. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 12 / 27 Connection in graphs Characterization of cut-edges in terms of cycles Theorem An edge is a cut-edge if and only if it belongs to no cycle. Proof : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 13 / 27 Cycles and bipartite graphs Outline 1 Connection in graphs 2 Cycles and bipartite graphs 3 Eulerian circuits 4 Hamiltonian Cycles Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 14 / 27 Cycles and bipartite graphs Definition : A walk is odd (resp. even) if its length is odd (resp. even). A closed walk W contains a cycle C if the vertices and edges of C occur as a sublist of W , in cyclic order but not necessarily consecutive. Lemma Every closed odd walk contains an odd cycle. Proof : By induction on the length l of a closed odd walk. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 15 / 27 Cycles and bipartite graphs Theorem (K¨ onig [1936]) A graph is bipartite if and only if it has no odd cycle. Proof : Remark The theorem implies that we can prove that a graph G is not bipartite by finding an odd cycle in G ; this is much easier than examining all possible bipartitions to prove that none work. When we want to prove that G is bipartite, we define a bipartition and prove that the two sets are independent ; this is easier than examining
bipartite by finding an odd cycle in G ; this is much easier than examining all possible bipartitions to prove that none work. When we want to prove that G is bipartite, we define a bipartition and prove that the two sets are independent ; this is easier than examining all cycles. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 16 / 27 Eulerian circuits Outline 1 Connection in graphs 2 Cycles and bipartite graphs 3 Eulerian circuits 4 Hamiltonian Cycles Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 17 / 27 Eulerian circuits Definition A graph is Eulerian if it has a closed trail containing all edges. We call a closed trail a circuit when we do not specify the first vertex but keep the list in cyclic order. An Eulerian circuit or Eulerian trail in a graph is a circuit or trail containing all the edges. An even graph is a graph with vertex degrees all even. A vertex is odd (resp. even) when its degree is odd (resp. even). A maximal path in a graph G is a path P in G that is not contained in a longer path. When a graph is finite, no path can extend forever, so maximal (non-extendible) paths exist. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 18 / 27 Eulerian circuits Lemma If every vertex of a graph G has degree at least 2, then G contains a cycle. Proof : by considering a maximal path P in G, and an endpoint of P. Theorem A graph G is Eulerian if and only if it has at most one nontrivial component and its vertices all have even degree. Proof of the theorem Necessity. Suppose that G has an Eulerian circuit C. Each passage of C through a vertex uses two incident edges, and the first edge is paired with the last at the first vertex. Hence every vertex has even degree. Also, two edges can be in the same trail only when they lie in the same component, so there is at most one nontrivial component. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 19 / 27 Eulerian circuits Proof (Cont.) Sufficiency. Assuming that the condition holds, we obtain an Eulerian circuit using induction on the number of edges, m. Basis step : m = 0. A closed
at most one nontrivial component. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 19 / 27 Eulerian circuits Proof (Cont.) Sufficiency. Assuming that the condition holds, we obtain an Eulerian circuit using induction on the number of edges, m. Basis step : m = 0. A closed trail consisting of one vertex suffices. Induction step : m > 0. With even degrees, each vertex in the nontrivial component of G has degree at least 2. By the previous Lemma, the nontrivial component has a cycle C. Let G′ be the graph obtained from G by deleting E(C). Since C has 0 or 2 edges at each vertex, each component of G′ is also an even graph. Since each component also is connected and has less than m edges, we can apply the induction hypothesis to conclude that each component of G′ has an Eulerian circuit. To combine these into an Eulerian circuit of G, we traverse C, but when a component of G′ is entered for the first time we detour along an Eulerian circuit of that component. This circuit ends at the vertex where we began the detour. When we complete the traversal of C, we have completed an Eulerian circuit of G. Illustration of the Eulerian circuit constructed : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 20 / 27 Eulerian circuits Proposition Every even graph decomposes into cycles. Proof : by induction on the number of edges. Proposition If G is a simple graph in which every vertex has degree at least k, then G contains a path of length at least k. If k ≥ 2, then G also contains a cycle of length at least k + 1. Proof : Consider an endpoint of a maximal path P. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 21 / 27 Hamiltonian Cycles Outline 1 Connection in graphs 2 Cycles and bipartite graphs 3 Eulerian circuits 4 Hamiltonian Cycles Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 22 / 27 Hamiltonian Cycles Definition A graph G is Hamiltonian if it contains a spanning cycle, which is a cycle that goes through each vertex of G exactly once. Such cycle is also called a Hamiltonian cycle. Example : The notion of a Hamiltonian cycle has its origins in a game invented in 1859 by Hamilton :
G is Hamiltonian if it contains a spanning cycle, which is a cycle that goes through each vertex of G exactly once. Such cycle is also called a Hamiltonian cycle. Example : The notion of a Hamiltonian cycle has its origins in a game invented in 1859 by Hamilton : The game consists of a regular wooden dodecahedron (polyhedron with 12 faces and 20 vertices), as shown in the following figure The player must go through the twenty vertices exactly once following the edges of the dodecahedron and return to his starting point. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 23 / 27 Hamiltonian Cycles Some solutions in 2D : In 3D : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 24 / 27 Hamiltonian Cycles Sufficient conditions Theorem (Dirac [1952]) If G is a simple graph with n ≥ 3 vertices and ∀v ∈ V (G), deg(v) ≥ n/2, then G is Hamiltonian. Proof The proof uses contradiction and extremality. If there is a non-Hamiltonian graph satisfying the hypotheses, then adding edges cannot reduce the minimum degree. Thus we may restrict our attention to maximal non-Hamiltonian graphs with minimum degree at least n/2, where “maximal” means that adding any edge joining nonadjacent vertices creates a spanning cycle. When uv ̸∈ E(G), the maximality of G implies that G + uv contains a Hamiltonian cycle and that cycle contains the edge uv. This implies that G has a spanning path v1, ··· , vn from u = v1 to v = vn. To prove the theorem, it suffices to make a small change in this cycle to avoid using the edge uv ; this will build a spanning cycle in G. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 25 / 27 Hamiltonian Cycles Proof (Cont.) If a neighbor of u directly follows a neighbor of v on the path, such as uvi+1 ∈ E(G) and vvi ∈ E(G), then ( u, vi+1, vi+2, ··· , v, vi , vi−1, ··· , u) is a spanning cycle in G. To prove that such a cycle exists, we show that there is a common index in the sets S and T defined by S = {i : uvi+1 ∈ E(G), 1 ≤ i ≤ n − 2} and T = {i : vvi ∈ E(G), 2 ≤ i ≤ n −
prove that such a cycle exists, we show that there is a common index in the sets S and T defined by S = {i : uvi+1 ∈ E(G), 1 ≤ i ≤ n − 2} and T = {i : vvi ∈ E(G), 2 ≤ i ≤ n − 1}. Summing the sizes of these sets yields |S ∪ T | + |S ∩ T | = |S| + |T | = deg(u) + deg(v) ≥ n/2 + n/2 = n. We have S ∪ T ⊂ J1, n − 1K, then |S ∪ T | ≤n − 1, hence |S ∩ T | ≥1. This means that S ∩ T ̸= ∅. So, we have established a contradiction by finding a spanning cycle in G ; hence there is no (maximal) non-Hamiltonian graph satisfying the hypotheses. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 26 / 27 Hamiltonian Cycles Remark Ore observed that the argument uses ∀v ∈ V (G), deg(v) ≥ n/2 only to show that deg( u) + deg(v) ≥ n. Therefore, we can weaken the requirement of minimum degree n/2 to require only that deg(u) + deg(v) ≥ n whenever uv ̸∈ E(G). Theorem (Ore [1960]) If G is a simple graph with n ≥ 3 vertices and deg(u) + deg(v) ≥ n for every pair of distinct non-adjacent vertices u and v of G, then G is Hamiltonian. Proof : The same as the above proof of Dirac’s theorem using the above remark. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 27 / 27
Chapter 3 : Directed graphs, and Coloring Omar Saadi omar.saadi@um6p.ma UM6P - College of Computing 1st year of the engineering degree of UM6P-CS Academic year 2023-2024 Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 1 / 16 Outline 1 Directed graphs 2 Coloring of graphs More details on this chapter can be found in Sect 1.4 and Sect. 5.1 of D. B. West’s book. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 2 / 16 Directed graphs Outline 1 Directed graphs 2 Coloring of graphs Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 3 / 16 Directed graphs Definition A directed graph or digraph G is a triple consisting of a vertex set V (G), an edge set E(G), and a function assigning each edge an ordered pair of vertices. The first vertex of the ordered pair is the tail of the edge, and the second is the head ; together, they are the endpoints. We say that an edge is an edge from its tail to its head. Definition In a digraph, a loop is an edge whose endpoints are equal. Multiple edges are edges having the same ordered pair of endpoints. A digraph is simple if each ordered pair is the head and tail of at most one edge ; one loop may be present at each vertex. In a simple digraph, we write uv for an edge with tail u and head v. If there is an edge from u to v, then v is a successor of u, and u is a predecessor of v. We write u → v for “there is an edge from u to v”. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 4 / 16 Directed graphs Example : Digraph of a Markov chain Consider a system that can be in n possible states s1, s2, ··· , sn. After being in the state si , the system will go to state sj with probability Pij . Note that for each state si , we have P j Pij = 1. The digraph G representing this Markov chain is such that : V (G) = {s1, s2, ··· , sn} si sj ∈ E(G) iff Pij > 0, in this case the edge si sj has a weight Pij . Definition : We say that a graph (or digraph)
= 1. The digraph G representing this Markov chain is such that : V (G) = {s1, s2, ··· , sn} si sj ∈ E(G) iff Pij > 0, in this case the edge si sj has a weight Pij . Definition : We say that a graph (or digraph) G is weighted if we associate to each edge a value, called a weight. Example : Suppose that weather has two states : good (G) and bad (B). Air masses move slowly enough that tomorrow’s weather tends to be like today’s. In most places, storms don’t linger long, so we might have transition probabilities as follows : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 5 / 16 Directed graphs Definition A digraph is a path if it is a simple digraph whose vertices can be linearly ordered so that there is an edge with tail u and head v if and only if v immediately follows u in the vertex ordering. A cycle is defined similarly using an ordering of the vertices on a circle. Definition The underlying graph of a digraph D is the graph G obtained by treating the edges of D as unordered pairs ; the vertex set and edge set remain the same, and the endpoints of an edge are the same in G as in D, but in G they become an unordered pair. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 6 / 16 Directed graphs Definition The definitions of subgraph, isomorphism and decomposition are the same for graphs and digraphs. In the adjacency matrix A(G) of a digraph G, the entry in position i, j is the number of edges from vi to vj . In the incidence matrix M(G) of a loopless digraph G, we set mij = 1 if vi is the tail of ej and mij = −1 if vi is the head of ej . Example : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 7 / 16 Directed graphs Definition A digraph is weakly connected if its underlying graph is connected. A digraph is strongly connected or strong if for each ordered pair u, v of vertices, there is a path from u to v. The strong components of a digraph are its maximal strong subgraphs. Examples : As a digraph, an n-vertex path has n strong components,
graph is connected. A digraph is strongly connected or strong if for each ordered pair u, v of vertices, there is a path from u to v. The strong components of a digraph are its maximal strong subgraphs. Examples : As a digraph, an n-vertex path has n strong components, but a cycle has only one strong component. In the diagraph below, the three circled subdigraphs are the strong components : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 8 / 16 Directed graphs Vertex degrees Definition Let v be a vertex in a digraph. The outdegree d+(v) is the number of edges with tail v. The indegree d−(v) is the number of edges with head v. The out-neighborhood or successor set N+(v) is {x ∈ V (G) : v → x}. The in-neighborhood or predecessor set N−(v) is {x ∈ V (G) : x → v}. The minimum and maximum indegree are δ−(G) and ∆ −(G) ; for outdegree we use δ+(G) and ∆ +(G). Proposition In a digraph G, P v∈V (G) d+(v) = |E(G)| = P v∈V (G) d−(v). Proof : Every edge has exactly one tail and exactly one head. Remark : In a graph, the minimum and maximum degree are denoted δ(G) and ∆( G), and we have P v∈V (G) d(v) = 2|E(G)|. ∆(G) is also called the degree of the graph. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 9 / 16 Directed graphs Eulerian digraphs The definitions of trail, walk, circuit, and the connection relation are the same in graphs and digraphs when we list edges as ordered pairs of vertices. Definition An Eulerian trail in a digraph (or graph) is a trail containing all edges. An Eulerian circuit is a closed trail containing all edges. A digraph is Eulerian if it has an Eulerian circuit. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 10 / 16 Directed graphs Characterization of an Eulerian digraph Lemma If G is a digraph withδ+(G) ≥ 1, then G contains a cycle. The same conclusion holds whenδ−(G) ≥ 1. Proof : Consider a maximal path in G. Theorem A digraph is Eulerian if and only ifd+(v) = d−(v) for each vertexv and the underlying graph has at most one nontrivial component. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 11 / 16 Coloring of
≥ 1. Proof : Consider a maximal path in G. Theorem A digraph is Eulerian if and only ifd+(v) = d−(v) for each vertexv and the underlying graph has at most one nontrivial component. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 11 / 16 Coloring of graphs Outline 1 Directed graphs 2 Coloring of graphs Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 12 / 16 Coloring of graphs Definition A k-coloring of a graph G is a labeling f : V (G) → S, where |S| = k. The labels are colors; the vertices of one color form a color class. A k-coloring is proper if adjacent vertices have different labels. A graph is k-colorable if it has a proper k-coloring. The chromatic number χ(G) is the least k such that G is k-colorable. If χ(G) = k, we say that G is k-chromatic. Remark In a proper coloring, each color class is an independent set, so G is k-colorable if and only if V (G) is the union of k independent sets. Thus “k-colorable” and “ k-partite” have the same meaning. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 13 / 16 Coloring of graphs Example Since a graph is 2-colorable if and only if it is bipartite, and C5 is not bipartite (because it contains an odd cycle), then C5 has a chromatic number at least 3. Since C5 is 3-colorable, as shown below, it has a chromatic number exactly 3. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 14 / 16 Coloring of graphs Lower bounds onχ(G) Recall : The independence number of a graph G, written α(G), is the biggest size of an independent subset of V (G). Definition The clique number of a graph G, written ω(G), is the maximum size of a clique in G. Proposition For every graph G with n vertices, we have χ(G) ≥ ω(G) and χ(G) ≥ n α(G). Proof : Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 15 / 16 Coloring of graphs An upper bound onχ(G) Algorithm : (Greedy coloring) The greedy coloring relative to a vertex ordering {v1, ··· , vn} of V (G) by the color set S is obtained by coloring vertices in the order v1, ··· , vn, assigning to vi the color with the smallest
of graphs An upper bound onχ(G) Algorithm : (Greedy coloring) The greedy coloring relative to a vertex ordering {v1, ··· , vn} of V (G) by the color set S is obtained by coloring vertices in the order v1, ··· , vn, assigning to vi the color with the smallest index in S that was not already used to color the neighbors of vi that were already colored. Proposition For every graph G, we have χ(G) ≤ ∆(G) + 1. Recall that ∆( G) is the degree of the graph G (i.e. the largest degree of its vertices). Proof : The greedy coloring doesn’t use more that ∆( G) + 1 colors. Remark : Note that the bound ∆( G) + 1 is optimal in the case of complete graphs and cycles. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 16 / 16
Chapter 4 : Trees Omar Saadi omar.saadi@um6p.ma UM6P - College of Computing 1st year of the engineering degree of UM6P-CS Academic year 2024-2025 Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 1 / 26 Outline 1 Basic properties 2 Distance in trees and graphs 3 Binary trees 4 Huffman coding More details on this chapter can be found in Sect. 2.1 and (last part of) Sect 2.3 of D. B. West’s book. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 2 / 26 Basic properties Outline 1 Basic properties 2 Distance in trees and graphs 3 Binary trees 4 Huffman coding Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 3 / 26 Basic properties Definition We say that a graph is acyclic if it doesn’t contain any cycle. A forest is an acyclic graph. A tree is a connected acyclic graph. A leaf (or pendant vertex) is a vertex of degree 1. Definition A spanning subgraph of G is a subgraph with vertex set V (G). A spanning tree is a spanning subgraph that is a tree. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 4 / 26 Basic properties Examples The following graph is a forest (no cycles). The following two graphs are trees (connected and no cycles). Their union is a forest. A tree is a connected forest, and every component of a forest is a tree. A graph with no cycles has no odd cycles ; hence trees and forests are bipartite. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 5 / 26 Basic properties Examples (Cont.) Paths are trees. A tree is a path if and only if its maximum degree is 2. A graph that is a tree has exactly one spanning tree ; the full graph itself. Remark A spanning subgraph of G doesn’t need to be connected, and a connected subgraph of G doesn’t need to be a spanning subgraph. For example : If n(G) ≥ 2, then the subgraph with vertex set V (G) and edge set ∅ is spanning but not connected. If n(G) ≥ 3, then a subgraph consisting of one edge and its endpoints is connected but not necessarily spanning. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 6 / 26 Basic properties Lemma Every
V (G) and edge set ∅ is spanning but not connected. If n(G) ≥ 3, then a subgraph consisting of one edge and its endpoints is connected but not necessarily spanning. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 6 / 26 Basic properties Lemma Every tree with at least two vertices has at least two leaves. Deleting a leaf from an n-vertex tree produces a tree with n − 1 vertices. Proof : Consider the endpoints of a maximal path and use the connectivity and the acyclicity properties of the tree. Remark This lemma implies that every tree with more than one vertex arises from a smaller tree by adding a vertex of degree 1. This remark is useful for induction reasoning when dealing with trees : growing an n + 1-vertex tree from an arbitrary n-vertex tree by adding a new neighbor at an arbitrary old vertex generates all trees with n + 1 vertices. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 7 / 26 Basic properties Characterizations of trees Theorem For an n-vertex graph G (with n ≥ 1), the following assertions are equivalent (and characterize the trees with n vertices) : 1 G is connected and has no cycles. 2 G is connected and has n - 1 edges. 3 G has n − 1 edges and no cycles. 4 For all u, v ∈ V (G), G has exactly one u, v-path. Proof : First prove the equivalence of 1 , 2, and 3 by proving that any two properties among the set {connected, acyclic, n − 1 edges} imply the third one. Then prove that 1 and 4 are equivalent. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 8 / 26 Basic properties Corollary 1 Every edge of a tree is a cut-edge. 2 Adding one edge to a tree forms exactly one cycle. 3 Every connected graph contains a spanning tree. Proof : Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 9 / 26 Basic properties Proposition If T , T ′ are spanning trees of a connected graph G and e ∈ E(T ) − E(T ′), then there is an edge e′ ∈ E(T ′) − E(T ) such that T − e + e′ is a spanning tree of G. Their is also
Proposition If T , T ′ are spanning trees of a connected graph G and e ∈ E(T ) − E(T ′), then there is an edge e′ ∈ E(T ′) − E(T ) such that T − e + e′ is a spanning tree of G. Their is also an edge e′′ ∈ E(T ′) − E(T ) such that T ′ + e − e′′ is a spanning tree of G. Proof : Consider the two components of T − e for the first result, and consider the unique cycle obtained by adding e to T ′ for the second result. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 10 / 26 Distance in trees and graphs Outline 1 Basic properties 2 Distance in trees and graphs 3 Binary trees 4 Huffman coding Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 11 / 26 Distance in trees and graphs Definition If G has a u, v-path, then the distance from u to v, written dG (u, v) or simply d(u, v), is the least length of a u, v-path. If G has no such path, then d(u, v) = ∞. The diameter (diam(G)) is max u,v∈V (G) d(u, v). The eccentricity of a vertex u, written ϵ(u), is max v∈V (G) d(u, v). The radius of a graph G, written rad( G), is min u∈V (G) ϵ(u). Remarks The diameter equals the maximum of the vertex eccentricities. In a disconnected graph, the diameter and radius (and every eccentricity) are infinite, because distance between vertices in different components is infinite. We use the word “diameter” due to its use in geometry, where it is the greatest distance between two elements of a set. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 12 / 26 Distance in trees and graphs Examples The Petersen graph has diameter 2, since nonadjacent vertices have a common neighbor. The cycle Cn has diameter ⌊n/2⌋. In these two examples, every vertex has the same eccentricity, and diam(G) = rad(G). Every path in a tree is the shortest (the only) path between its endpoints, so the diameter of a tree is the length of its longest path. In the graph below, each vertex is labeled with its eccentricity. The radius is 2, the diameter is 4, and the length of the longest path is
tree is the shortest (the only) path between its endpoints, so the diameter of a tree is the length of its longest path. In the graph below, each vertex is labeled with its eccentricity. The radius is 2, the diameter is 4, and the length of the longest path is 7. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 13 / 26 Distance in trees and graphs Proposition If G is a simple graph, then diam( G) ≥ 3 ⇒ diam(G) ≤ 3. Proof : Use the fact that if diam( G) ≥ 3 then there exist nonadjacent vertices u, v ∈ V (G) with no common neighbor. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 14 / 26 Distance in trees and graphs Definition The center of a graph G is the subgraph induced by the vertices of minimum eccentricity. Remark : The center of a graph is the full graph if and only if the radius and diameter are equal. Theorem (Jordan [1869]) The center of a tree is a vertex or an edge. Proof : We use induction on the number of vertices in a tree T , where we obtain a smaller tree T ′ by deleting every leaf of T . Use the fact that ∀u ∈ V (T ′), ϵT′ (u) = ϵT (u) − 1. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 15 / 26 Binary trees Outline 1 Basic properties 2 Distance in trees and graphs 3 Binary trees 4 Huffman coding Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 16 / 26 Binary trees Definition A rooted tree is a tree with one vertex r chosen as root. For each vertex v, let P(v) be the unique v, r-path. The parent of v is its neighbor on P(v) ; its children are its other neighbors. Its ancestors are the vertices of P(v) − v. Its descendants are the vertices u such that P(u) contains v. The leaves are the vertices with no children. A rooted plane tree or planted tree is a rooted tree with a left-to-right ordering specified for the children of each vertex. Example : Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 17 / 26 Binary trees Definition A binary tree is a rooted plane tree where
rooted plane tree or planted tree is a rooted tree with a left-to-right ordering specified for the children of each vertex. Example : Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 17 / 26 Binary trees Definition A binary tree is a rooted plane tree where each vertex has at most two children, and each child of a vertex is designated as its left child or right child. The subtrees rooted at the children of the root are the left subtree and the right subtree of the tree. A k-ary tree allows each vertex up to k children. Remark Binary trees permit storage of data for quick access. We store each item at a leaf and access it by following the path from the root. We encode the path by recording 0 when we move to a left child and 1 when we move to a right child. For each leaf, the search time is the length of its code word. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 18 / 26 Huffman coding Outline 1 Basic properties 2 Distance in trees and graphs 3 Binary trees 4 Huffman coding Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 19 / 26 Huffman coding In a text file, each character is stored as a binary list. The classical way to encode characters is to use the ASCII code. It encodes each character using 7 bits. This allows to encode 128 characters that appear in text files. The ASCII table is the following : Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 20 / 26 Huffman coding Prefix-free coding Objective : Given a text file, we want to encode each character appearing in that text using a binary list with the goal of minimizing the total number of bits needed to store this text file. The length of code words may vary ; so we need a way to recognize the end of the current word. Idea : If no code word is an initial portion of another, we can easily recover our characters. We can do this by going through the list of bits (from left to right), and at each time that a sublist of bits correspond to a code of a character we make the transformation “bits to character”, and start again for
of another, we can easily recover our characters. We can do this by going through the list of bits (from left to right), and at each time that a sublist of bits correspond to a code of a character we make the transformation “bits to character”, and start again for the remaining bits. Definition : We call such coding a prefix-free coding. Example : If we have only three characters a, b, c with the following prefix-free coding a ↔ 1, b ↔ 01, c ↔ 00, then we can get the following encodings : aabacbc ↔ 11011000100 and ccbaac ↔ 0000011100. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 21 / 26 Huffman coding Remark Under the prefix-free condition, the binary code words correspond to the leaves of a binary tree using the left/right encoding described above. Input : The text file uses n characters c1, ··· , cn with probabilities of occurrence p1, ··· , pn respectively. Notice that pi is the number of occurrences of ci divided by the total number N of characters in the text. Goal : Construct the binary tree such that the bit lengths l1, ··· , ln assigned to the leaves c1, ··· , cn are such that : The expected length of a code word X i∈[n] pi li is minimal. Notice that we are minimizing indeed the total length of the encoding N × P i∈[n] pi li . Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 22 / 26 Huffman coding Huffman’s Algorithm Input : Weights (frequencies or probabilities) p1, ··· , pn. Output : Prefix-free code (equivalently, a binary tree). Idea : Infrequent items should have longer codes ; put infrequent items deeper by combining them into parent vertices. Initial case : When n = 2, the optimal length is one, with 0 and 1 being the codes assigned to the two items (the tree has a root and two leaves). Recursion : When n > 2, replace the two items with the smallest probabilities p, p′ with a single item q of weight p + p′. Treat the smaller set as a problem with n − 1 items. After solving it, give children with weights p, p′ to the resulting leaf with weight q. Equivalently, replace the code computed for the combined item q with its extensions by 1
item q of weight p + p′. Treat the smaller set as a problem with n − 1 items. After solving it, give children with weights p, p′ to the resulting leaf with weight q. Equivalently, replace the code computed for the combined item q with its extensions by 1 and 0, assigned to the items that were replaced. Notice that each vertex that is not a leaf has exactly two children. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 23 / 26 Huffman coding Example Consider eight items with frequencies 5 , 1, 1, 7, 8, 2, 3, 6. Huffman’s algorithm will output the tree below in the left, working from the bottom up. The values of the vertices are the (combined) frequencies. We obtain code words as shown in the tree below in the right. In their original order, the items have code words 100, 00000, 00001, 01, 11, 0001, 001, and 101. The expected length of a code word is L = P i pi li = 90/33. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 24 / 26 Huffman coding Optimality of Huffman coding Theorem Given a probability distribution {p1, ··· , pn} on n items, Huffman’s algorithm produces the prefix-free code with minimum expected length. Proof We use induction on n. Basis step : n = 2. The algorithm encodes each item as a single bit, which is optimal. Induction step : n > 2. Suppose that the algorithm computes the optimal code when given a distribution for n − 1 items. With n items, an optimal binary tree T must assign the items with probabilities p1 ≥ ··· ≥pn to leaves in increasing order of depth, because otherwise we can exchange two items and get a strictly better encoding. Therefore the two items with the smallest probabilities are assigned to leaves of greatest depth. Since permuting items at a given depth doesn’t change the expected length, we may assume that items n and n −1 appear as siblings at greatest depth in T . Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 25 / 26 Huffman coding Proof (Cont.) Let T ′ be the tree obtained from T by deleting these leaves, and let {q1, ··· , qn−1} be the probability distribution obtained by replacing {pn−1, pn} by qn−1 = pn−1 +
(College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 25 / 26 Huffman coding Proof (Cont.) Let T ′ be the tree obtained from T by deleting these leaves, and let {q1, ··· , qn−1} be the probability distribution obtained by replacing {pn−1, pn} by qn−1 = pn−1 + pn, and ∀i ∈ [n − 2], qi = pi . The tree T ′ yields a code for {qi }. Notice that, if k is the depth of the leaf assigned of weight qn−1 in T ′, we have length(T ) = X i∈[n] pi li = X i∈[n−2] pi li + (k + 1)(pn−1 + pn) = P i∈[n−1] qi li + qn−1 = length( T ′) + qn−1 . So it suffices that T ′ is optimal to get that T is optimal because they have the same length up to the fixed constant qn−1. By the induction hypothesis, an optimal choice for T ′ is obtained by applying Huffman’s algorithm to {qi }. Since the replacement of {pn−1, pn} by qn−1 is exactly the first step of Huffman’s Algorithm for {pi }, we conclude that Huffman’s algorithm generates the optimal tree T for {pi }. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 26 / 26
Chapter 5 : Minimum Spanning Tree Omar Saadi omar.saadi@um6p.ma UM6P - College of Computing 1st year of the engineering degree of UM6P-CS Academic year 2024-2025 Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 1 / 16 Outline 1 Introduction 2 Kruskal’s Algorithm 3 Prim’s Algorithm Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 2 / 16 Introduction Outline 1 Introduction 2 Kruskal’s Algorithm 3 Prim’s Algorithm Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 3 / 16 Introduction Introduction Definition A weighted graphis a graph with numerical labels on the edges. For a weighted connected graph, a minimal spanning treeis a spanning tree that has the smallest (total) weight possible. Example : Consider a graph such that : Each vertex is a city When two cities can be connected by a road, then there is an edge between them in the graph, and its weight is the cost of constructing that road. Here, connecting all the cities with the smallest total construction cost is exaclty the minimum spanning tree problem. In the following the weights are allowed to be positive or negative. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 4 / 16 Kruskal’s Algorithm Outline 1 Introduction 2 Kruskal’s Algorithm 3 Prim’s Algorithm Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 5 / 16 Kruskal’s Algorithm Kruskal’s Algorithm Input : A weighted connected graph. Idea : Maintain an acyclic spanning subgraph H, enlarging it by edges with low weight to form a spanning tree. Initialization :Set V (H) = V (G) and E(H) = ∅. Iteration :If the next cheapest edge joins two components of H, then include it in H ; otherwise, discard it. Terminate when H is connected. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 6 / 16 Kruskal’s Algorithm Example The following example shows a weighted connected graph with the spanning tree given by Kruskal’s algorithm. The edges are add the following order : 1 , 2, 3, 4, 7, 10. Remark Unsophisticated locally optimal heuristics are called greedy algorithms. They usually don’t guarantee optimal solutions, but Kruskal’s algorithm is an example of a greedy algorithm that gives an optimal solution (see next theorem). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 7 / 16 Kruskal’s Algorithm Example The following example shows a weighted
called greedy algorithms. They usually don’t guarantee optimal solutions, but Kruskal’s algorithm is an example of a greedy algorithm that gives an optimal solution (see next theorem). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 7 / 16 Kruskal’s Algorithm Example The following example shows a weighted connected graph with the spanning tree given by Kruskal’s algorithm. The edges are add the following order : 1 , 2, 3, 4, 7, 10. Remark Unsophisticated locally optimal heuristics are called greedy algorithms. They usually don’t guarantee optimal solutions, but Kruskal’s algorithm is an example of a greedy algorithm that gives an optimal solution (see next theorem). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 7 / 16 Kruskal’s Algorithm Theorem (Kruskal [1956]) In a connected weighted graphG, Kruskal’s algorithm constructs a minimum-weight spanning tree. Proof First we show that the algorithm produces a tree. Indeed, at each iteration, while H is not yet connected, there is at least an edge that connects two different components of H (because G is connected), so at each iteration an edge is added to H. It becomes connected exactely after adding n − 1 edges, and so it becomes a tree. Let T be the resulting tree, and let T′ be a spanning tree of minimum weight. If T = T′, we are done. If T ̸= T′, let e be the first edge chosen for T that is not in T′. Adding e to T′ creates one cycle C. Since T has no cycle, C has an edge e′ ̸∈ E(T). Consider the spanning tree T′′ = T′ + e − e′. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 8 / 16 Kruskal’s Algorithm Proof (Cont.) Since T′ contains e′ and all the edges of T chosen before e, then e′ could be added to T when the algorithm choosed e (without creating a cycle). So both e′ and e were available when the algorithm choosed e, and hence w(e) ≤ w(e′). Thus T′′ = T′ + e − e′ is a spanning tree with weight that doesn’t exceed the weight of T′ and that agrees with T for a longer initial list of edges than T′ does. In particular T′′ is also a minimum spanning tree. Repeating this argument yields a minimum-weight spanning tree that agrees completely with T. Therefore T is a
with weight that doesn’t exceed the weight of T′ and that agrees with T for a longer initial list of edges than T′ does. In particular T′′ is also a minimum spanning tree. Repeating this argument yields a minimum-weight spanning tree that agrees completely with T. Therefore T is a minimum spanning tree. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 9 / 16 Kruskal’s Algorithm Let n = |V (G)| and m = |E(G)|. Implementation steps : First sort the m edge weights. Maintain for each vertex the label of the component containing it. Add the next cheapest edge if its endpoints have different labels, and merge the two components by changing the label of each vertex in the smaller component to the label of the larger one. Complexity : Since the size of the component at least doubles when a label changes (we are changing the smaller one), each label changes at most log2(n) times, and the total number of changes is at most n log2(n). With this labeling method, the running time for large graphs depends on the time to sort m weights of the edges, which is O(m log(m)). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 10 / 16 Prim’s Algorithm Outline 1 Introduction 2 Kruskal’s Algorithm 3 Prim’s Algorithm Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 11 / 16 Prim’s Algorithm Input : A weighted connected graph. Idea : Growing a subgraph H from one isolated vertex by iteratively adding the cheapest edge from a vertex already reached to a vertex not yet reached to form a spanning tree. Initialization :V (H) = {v} and E(H) = ∅ for a given starting vertex v. Iteration :Add to H the cheapest edge (with its other endpoint) from a vertex already in H to a vertex outside H. Terminate when H is spanning. Example : In the above example, if we start from the vertex in the bottom left, we obtain the same spanning tree in the following order of edges : 10 , 2, 4, 3, 7, 1. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 12 / 16 Prim’s Algorithm Input : A weighted connected graph. Idea : Growing a subgraph H from one isolated vertex by iteratively adding the cheapest edge from a vertex already reached to a vertex not
3, 7, 1. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 12 / 16 Prim’s Algorithm Input : A weighted connected graph. Idea : Growing a subgraph H from one isolated vertex by iteratively adding the cheapest edge from a vertex already reached to a vertex not yet reached to form a spanning tree. Initialization :V (H) = {v} and E(H) = ∅ for a given starting vertex v. Iteration :Add to H the cheapest edge (with its other endpoint) from a vertex already in H to a vertex outside H. Terminate when H is spanning. Example : In the above example, if we start from the vertex in the bottom left, we obtain the same spanning tree in the following order of edges : 10 , 2, 4, 3, 7, 1. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 12 / 16 Prim’s Algorithm Theorem (Jarnik [1930], Prim [1957]) In a connected weighted graphG, Prim’s algorithm constructs a minimum-weight spanning tree. Proof First we show that the algorithm produces a spanning tree. Indeed, at each iteration, we are keeping H connected, and we are adding one edge that does not create any cycle. So H is always a tree. After exactely n − 1 iterations, it becomes a spanning tree. Using the same idea of proof as Kruskal’s algorithm : Let T be the resulting tree from Prim’s algorithm, and let T′ be a spanning tree of minimum weight. If T = T′, we are done. If T ̸= T′, let e be the first edge chosen (at iteration i) for T that is not in T′. At iteration i − 1, we denote the set obtain by {v0, ··· , vi −1}. the edge e connects {v0, ··· , vi −1} to V (G) \ {v0, ··· , vi −1}. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 13 / 16 Prim’s Algorithm Proof (Cont.) Now, adding e to T′ creates one cycle C. So, C − e is a path from a vertex in {v0, ··· , vi −1} to a vertex in V (G) \ {v0, ··· , vi −1}. Therefore, C − e contains an edge e′ that connects {v0, ··· , vi −1} to V (G) \ {v0, ··· , vi −1}. Then e′ could be added to T when the algorithm choosed e (at
−1} to a vertex in V (G) \ {v0, ··· , vi −1}. Therefore, C − e contains an edge e′ that connects {v0, ··· , vi −1} to V (G) \ {v0, ··· , vi −1}. Then e′ could be added to T when the algorithm choosed e (at iteration i), and hence w(e) ≤ w(e′). Thus T′′ = T′ + e − e′ is a spanning tree with weight that doesn’t exceed the weight of T′ and that agrees with T for a longer initial list of edges than T′ does. In particular T′′ is also a minimum spanning tree. Repeating this argument yields a minimum-weight spanning tree that agrees completely with T. Therefore T is a minimum spanning tree. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 14 / 16 Prim’s Algorithm Implementation steps and complexity : Using the weights matrix w(u, v) giving the weight of the edge ( u, v) (with w(u, v) = +∞ if (u, v) ̸∈ E(H)). Idea : Construct and update a first list d[v], v ̸∈ H, with d[v] being the cheapest weight of an edge that connects v to some vertex u already in H. Also consider a second list p[v], v ̸∈ H, with p[v] = u being the neighbor in H to which v is connected with the cheapest weight d[v]. The steps and the corresponding complexity are as follows (next slide) : Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 15 / 16 Prim’s Algorithm 1 Start with H = v0 (any initial vertex v0). [This takes O(1)] 2 For all v ̸= v0, initialize d[v] = w(v0, v), and p[v] = v0 if (v, v0) ∈ E(H) and p[v] = ∅ otherwise. [This takes O(n)] 3 While H is still not spanning do the following : Extract the cheapest weight in d corresponding to some vertex vi . Remove d[vi ] and p[vi ] from d and p. Add the vertex vi and the edge (p[vi ], vi ) to H. [this takes O(n)]. Update d and p : For all neighbours v of vi such that v ̸∈ H, do : If w(v, vi ) < d[v], then d[v] = w(v, vi ) and p[v] = vi . [this takes O(deg(vi ) = O(n)]. Complexity :Combining the above complexities, we get that the total time complexity is O(n2).
For all neighbours v of vi such that v ̸∈ H, do : If w(v, vi ) < d[v], then d[v] = w(v, vi ) and p[v] = vi . [this takes O(deg(vi ) = O(n)]. Complexity :Combining the above complexities, we get that the total time complexity is O(n2). Remark :This complexity can be improved to O(m log(n)) using other data structures to represent the graph (where m = |E(G)|). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 16 / 16
Chapter 6 : Breadth-First Search and Depth-First Search Omar Saadi omar.saadi@um6p.ma UM6P - College of Computing 1st year of the engineering degree of UM6P-CS Academic year 2024-2025 Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 1 / 24 Outline 1 Breadth-First Search (BFS) 2 Depth-First Search (DFS) Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 2 / 24 Breadth-First Search (BFS) Outline 1 Breadth-First Search (BFS) 2 Depth-First Search (DFS) Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 3 / 24 Breadth-First Search (BFS) Introduction Given a graph G, there are several problems one wants to solve related to the connectivity of the graph. Those include the following : Given a pair of vertices ( u, v), is there a path in G from u to v ? Given a pair of vertices ( u, v), what is the distance d(u, v) and a shortest path from u to v ? Given a vertex s, find d(s, v) for all v ∈ V (G) and a shortest path tree* containing a shortest path from s to every v ∈ V . * : A shortest path tree is a tree of G where the unique path from s to any vertex v inside this tree is a shortest path from s to v in G. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 4 / 24 Breadth-First Search (BFS) Introduction Given a graph G, there are several problems one wants to solve related to the connectivity of the graph. Those include the following : Given a pair of vertices ( u, v), is there a path in G from u to v ? Given a pair of vertices ( u, v), what is the distance d(u, v) and a shortest path from u to v ? Given a vertex s, find d(s, v) for all v ∈ V (G) and a shortest path tree* containing a shortest path from s to every v ∈ V . * : A shortest path tree is a tree of G where the unique path from s to any vertex v inside this tree is a shortest path from s to v in G. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 4 / 24 Breadth-First Search (BFS) Introduction Given a graph G, there are several problems one wants
the unique path from s to any vertex v inside this tree is a shortest path from s to v in G. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 4 / 24 Breadth-First Search (BFS) Introduction Given a graph G, there are several problems one wants to solve related to the connectivity of the graph. Those include the following : Given a pair of vertices ( u, v), is there a path in G from u to v ? Given a pair of vertices ( u, v), what is the distance d(u, v) and a shortest path from u to v ? Given a vertex s, find d(s, v) for all v ∈ V (G) and a shortest path tree* containing a shortest path from s to every v ∈ V . * : A shortest path tree is a tree of G where the unique path from s to any vertex v inside this tree is a shortest path from s to v in G. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 4 / 24 Breadth-First Search (BFS) Introduction Given a graph G, there are several problems one wants to solve related to the connectivity of the graph. Those include the following : Given a pair of vertices ( u, v), is there a path in G from u to v ? Given a pair of vertices ( u, v), what is the distance d(u, v) and a shortest path from u to v ? Given a vertex s, find d(s, v) for all v ∈ V (G) and a shortest path tree* containing a shortest path from s to every v ∈ V . * : A shortest path tree is a tree of G where the unique path from s to any vertex v inside this tree is a shortest path from s to v in G. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 4 / 24 Breadth-First Search (BFS) Shortest Paths Tree Question How to return a shortest path from the source vertex s to every vertex v in the graph ? Problem Many paths could have length Ω( |V |), so returning every path could require Ω(|V |2) time. Idea For every v ∈ V , store its parent P(v) in a shortest path from s to v. This set of parents has
to every vertex v in the graph ? Problem Many paths could have length Ω( |V |), so returning every path could require Ω(|V |2) time. Idea For every v ∈ V , store its parent P(v) in a shortest path from s to v. This set of parents has an Ω( |V |) size and comprises a shortest paths tree. It provides a reversed shortest paths back to s from every vertex v reachable from s Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 5 / 24 Breadth-First Search (BFS) Shortest Paths Tree Question How to return a shortest path from the source vertex s to every vertex v in the graph ? Problem Many paths could have length Ω( |V |), so returning every path could require Ω(|V |2) time. Idea For every v ∈ V , store its parent P(v) in a shortest path from s to v. This set of parents has an Ω( |V |) size and comprises a shortest paths tree. It provides a reversed shortest paths back to s from every vertex v reachable from s Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 5 / 24 Breadth-First Search (BFS) Shortest Paths Tree Question How to return a shortest path from the source vertex s to every vertex v in the graph ? Problem Many paths could have length Ω( |V |), so returning every path could require Ω(|V |2) time. Idea For every v ∈ V , store its parent P(v) in a shortest path from s to v. This set of parents has an Ω( |V |) size and comprises a shortest paths tree. It provides a reversed shortest paths back to s from every vertex v reachable from s Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 5 / 24 Breadth-First Search (BFS) Breadth-First Search (BFS) We want to : Store d(s, v) and P(v) in Set data structures mapping vertices v to distance and parent respectively. (If no path from s to v, do not store v in P and set d(s, v) to ∞). Idea : Explore graph nodes in increasing order of distance from s. Goal :Compute level sets Li = {v | v ∈ V and d(s, v) = i} (i.e., all vertices at distance i from s). Claims : Every vertex v ∈ Li must be
set d(s, v) to ∞). Idea : Explore graph nodes in increasing order of distance from s. Goal :Compute level sets Li = {v | v ∈ V and d(s, v) = i} (i.e., all vertices at distance i from s). Claims : Every vertex v ∈ Li must be adjacent to some vertex u ∈ Li−1 (i.e., v ∈ Adj(u)). No vertex that is in Lj for some j < i, appears in Li . Invariant :d(s, v) and P(v) have been computed correctly for all v in any Lj for j < i. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 6 / 24 Breadth-First Search (BFS) Breadth-First Search (BFS) We want to : Store d(s, v) and P(v) in Set data structures mapping vertices v to distance and parent respectively. (If no path from s to v, do not store v in P and set d(s, v) to ∞). Idea : Explore graph nodes in increasing order of distance from s. Goal :Compute level sets Li = {v | v ∈ V and d(s, v) = i} (i.e., all vertices at distance i from s). Claims : Every vertex v ∈ Li must be adjacent to some vertex u ∈ Li−1 (i.e., v ∈ Adj(u)). No vertex that is in Lj for some j < i, appears in Li . Invariant :d(s, v) and P(v) have been computed correctly for all v in any Lj for j < i. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 6 / 24 Breadth-First Search (BFS) Breadth-First Search (BFS) We want to : Store d(s, v) and P(v) in Set data structures mapping vertices v to distance and parent respectively. (If no path from s to v, do not store v in P and set d(s, v) to ∞). Idea : Explore graph nodes in increasing order of distance from s. Goal :Compute level sets Li = {v | v ∈ V and d(s, v) = i} (i.e., all vertices at distance i from s). Claims : Every vertex v ∈ Li must be adjacent to some vertex u ∈ Li−1 (i.e., v ∈ Adj(u)). No vertex that is in Lj for some j < i, appears in Li . Invariant :d(s, v) and P(v) have been computed correctly for all v in any Lj for j < i. Omar Saadi (College of Computing)
adjacent to some vertex u ∈ Li−1 (i.e., v ∈ Adj(u)). No vertex that is in Lj for some j < i, appears in Li . Invariant :d(s, v) and P(v) have been computed correctly for all v in any Lj for j < i. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 6 / 24 Breadth-First Search (BFS) Breadth-First Search (BFS) We want to : Store d(s, v) and P(v) in Set data structures mapping vertices v to distance and parent respectively. (If no path from s to v, do not store v in P and set d(s, v) to ∞). Idea : Explore graph nodes in increasing order of distance from s. Goal :Compute level sets Li = {v | v ∈ V and d(s, v) = i} (i.e., all vertices at distance i from s). Claims : Every vertex v ∈ Li must be adjacent to some vertex u ∈ Li−1 (i.e., v ∈ Adj(u)). No vertex that is in Lj for some j < i, appears in Li . Invariant :d(s, v) and P(v) have been computed correctly for all v in any Lj for j < i. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 6 / 24 Breadth-First Search (BFS) BFS Algorithm Base case (i = 0) : L0 = {s}, d(s, s) = 0, P(s) = None Inductive Step : To compute Li : For every vertex u ∈ Li−1 : For every vertex v ∈ Adj(u) that does not appear in any Lj for j < i, do : Add v to Li , set d(s, v) = i, and set P(v) = u. Repeatedly compute Li from Lj for j < i for increasing i until Li is the empty set. Set d(s, v) = ∞ for any v ∈ V for which d(s, v) was not set. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 7 / 24 Breadth-First Search (BFS) Remarks The principle of the above Breadth-First Search algorithm is : Start with the source vertex s Visit his neighbours Then visit the neighbours of its neighbours (that were not yet explored) and so on ··· until visiting all reachable vertices from s. Recall that the largest distance from a fixed vertex u to another vertex is the eccentricity ϵ(u). Hence BFS started at u allows to compute this eccentricity.
Then visit the neighbours of its neighbours (that were not yet explored) and so on ··· until visiting all reachable vertices from s. Recall that the largest distance from a fixed vertex u to another vertex is the eccentricity ϵ(u). Hence BFS started at u allows to compute this eccentricity. So we can compute the diameter of a graph by running Breadth-First Search from each vertex. BFS can be applied in its same above format for directed graphs. In this case, the neighbors of u are taken in the directed sens. BFS can also be applied to the particular case of trees to do a tree traversal. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 8 / 24 Breadth-First Search (BFS) Remarks The principle of the above Breadth-First Search algorithm is : Start with the source vertex s Visit his neighbours Then visit the neighbours of its neighbours (that were not yet explored) and so on ··· until visiting all reachable vertices from s. Recall that the largest distance from a fixed vertex u to another vertex is the eccentricity ϵ(u). Hence BFS started at u allows to compute this eccentricity. So we can compute the diameter of a graph by running Breadth-First Search from each vertex. BFS can be applied in its same above format for directed graphs. In this case, the neighbors of u are taken in the directed sens. BFS can also be applied to the particular case of trees to do a tree traversal. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 8 / 24 Breadth-First Search (BFS) Remarks The principle of the above Breadth-First Search algorithm is : Start with the source vertex s Visit his neighbours Then visit the neighbours of its neighbours (that were not yet explored) and so on ··· until visiting all reachable vertices from s. Recall that the largest distance from a fixed vertex u to another vertex is the eccentricity ϵ(u). Hence BFS started at u allows to compute this eccentricity. So we can compute the diameter of a graph by running Breadth-First Search from each vertex. BFS can be applied in its same above format for directed graphs. In this case, the neighbors of u are taken in the directed sens. BFS can also be applied to the particular case of trees to do a tree traversal. Omar Saadi (College of Computing)
Search from each vertex. BFS can be applied in its same above format for directed graphs. In this case, the neighbors of u are taken in the directed sens. BFS can also be applied to the particular case of trees to do a tree traversal. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 8 / 24 Breadth-First Search (BFS) Remarks The principle of the above Breadth-First Search algorithm is : Start with the source vertex s Visit his neighbours Then visit the neighbours of its neighbours (that were not yet explored) and so on ··· until visiting all reachable vertices from s. Recall that the largest distance from a fixed vertex u to another vertex is the eccentricity ϵ(u). Hence BFS started at u allows to compute this eccentricity. So we can compute the diameter of a graph by running Breadth-First Search from each vertex. BFS can be applied in its same above format for directed graphs. In this case, the neighbors of u are taken in the directed sens. BFS can also be applied to the particular case of trees to do a tree traversal. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 8 / 24 Breadth-First Search (BFS) Example Performing BFS search on the following tree, starting from the vertex 1, leads to the next traversal of the tree : Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 9 / 24 Breadth-First Search (BFS) Proposition Breadth-first search correctly computes all d(s, v) and P(v) for every v ∈ V . Proof : Straightforward by an induction over i. Proposition Breadth-first search runs in O(|V | + |E|) time (i.e. linear time). Proof : (Next slide) Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 10 / 24 Breadth-First Search (BFS) Proposition Breadth-first search correctly computes all d(s, v) and P(v) for every v ∈ V . Proof : Straightforward by an induction over i. Proposition Breadth-first search runs in O(|V | + |E|) time (i.e. linear time). Proof : (Next slide) Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 10 / 24 Breadth-First Search (BFS) Proof Algorithm adds each vertex u to at most one level Li and spends O(1) time for each v ∈ Adj(u). Time complexity upper bounded by O(1) × P u∈V deg(u) = O(|E|) Spend O(|V |) at end to
Foundations (GA) Computer Science School 10 / 24 Breadth-First Search (BFS) Proof Algorithm adds each vertex u to at most one level Li and spends O(1) time for each v ∈ Adj(u). Time complexity upper bounded by O(1) × P u∈V deg(u) = O(|E|) Spend O(|V |) at end to assign d(s, v) for vertices v ∈ V not reachable from s ⇒ Breadth-first search runs in linear time O(|V | + |E|) Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 11 / 24 Breadth-First Search (BFS) Proof Algorithm adds each vertex u to at most one level Li and spends O(1) time for each v ∈ Adj(u). Time complexity upper bounded by O(1) × P u∈V deg(u) = O(|E|) Spend O(|V |) at end to assign d(s, v) for vertices v ∈ V not reachable from s ⇒ Breadth-first search runs in linear time O(|V | + |E|) Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 11 / 24 Breadth-First Search (BFS) Application : checking strongly connectivity Problem Given a directed graph, check if it is strongly connected or not. Solution 1 (a na ¨ ıve one) Perform BFS starting from every vertex in the graph. If each BFS call visits every other vertex in the graph, then the graph is strongly connected. Complexity :We are performing BFS |V | times, and each call of BFS need O(|V | + |E|), so the total complexity is O(|V |(|V | + |E|)). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 12 / 24 Breadth-First Search (BFS) Application : checking strongly connectivity Problem Given a directed graph, check if it is strongly connected or not. Solution 1 (a na ¨ ıve one) Perform BFS starting from every vertex in the graph. If each BFS call visits every other vertex in the graph, then the graph is strongly connected. Complexity :We are performing BFS |V | times, and each call of BFS need O(|V | + |E|), so the total complexity is O(|V |(|V | + |E|)). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 12 / 24 Breadth-First Search (BFS) Solution 2 Choose a vertex u, and perform BFS starting from u. Reverse the direction of all edges in the digraph G, and perform again BFS starting from the same vertex u. Proposition The graph is strongly connected if
Foundations (GA) Computer Science School 12 / 24 Breadth-First Search (BFS) Solution 2 Choose a vertex u, and perform BFS starting from u. Reverse the direction of all edges in the digraph G, and perform again BFS starting from the same vertex u. Proposition The graph is strongly connected if and only if both calls of BFS visit every vertex in the graph. Proof : There is a path from u to every other vertex v, and also a path from every other vertex v to u. Complexity :We are performing BFS twice, so the total complexity is O(|V | + |E|). Remark :this problem can be solved also by DFS (described below) instead of BFS. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 13 / 24 Breadth-First Search (BFS) Solution 2 Choose a vertex u, and perform BFS starting from u. Reverse the direction of all edges in the digraph G, and perform again BFS starting from the same vertex u. Proposition The graph is strongly connected if and only if both calls of BFS visit every vertex in the graph. Proof : There is a path from u to every other vertex v, and also a path from every other vertex v to u. Complexity :We are performing BFS twice, so the total complexity is O(|V | + |E|). Remark :this problem can be solved also by DFS (described below) instead of BFS. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 13 / 24 Breadth-First Search (BFS) Solution 2 Choose a vertex u, and perform BFS starting from u. Reverse the direction of all edges in the digraph G, and perform again BFS starting from the same vertex u. Proposition The graph is strongly connected if and only if both calls of BFS visit every vertex in the graph. Proof : There is a path from u to every other vertex v, and also a path from every other vertex v to u. Complexity :We are performing BFS twice, so the total complexity is O(|V | + |E|). Remark :this problem can be solved also by DFS (described below) instead of BFS. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 13 / 24 Depth-First Search (DFS) Outline 1 Breadth-First Search (BFS) 2 Depth-First Search (DFS) Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 14 / 24
be solved also by DFS (described below) instead of BFS. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 13 / 24 Depth-First Search (DFS) Outline 1 Breadth-First Search (BFS) 2 Depth-First Search (DFS) Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 14 / 24 Depth-First Search (DFS) Depth-First Search (DFS) Goal : Search a graph from a vertex s, like BFS. Solve Single Source Reachability : i.e. Given a vertex s (source), identify all the vertices u reachable from s and provide a path from s to u (not necessarily a shortest path). Return parent tree of parent pointers back to s (like BFS, but not necessarily shortest paths). Idea : Visit outgoing adjacencies recursively, but never revisit a vertex. Meaning that : follow any path until you get stuck, backtrack until finding an unexplored path to explore. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 15 / 24 Depth-First Search (DFS) Depth-First Search (DFS) Goal : Search a graph from a vertex s, like BFS. Solve Single Source Reachability : i.e. Given a vertex s (source), identify all the vertices u reachable from s and provide a path from s to u (not necessarily a shortest path). Return parent tree of parent pointers back to s (like BFS, but not necessarily shortest paths). Idea : Visit outgoing adjacencies recursively, but never revisit a vertex. Meaning that : follow any path until you get stuck, backtrack until finding an unexplored path to explore. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 15 / 24 Depth-First Search (DFS) DFS algorithm : P(s) = None, then run visit( s), where the function “visit” is defined recursively as follows : visit(u) : for every v ∈ Adj(u) that does not appear in P : Set P(v) = u and recursively call visit( v). DFS finishes visiting vertex u (for use later !). Remarks : The principle of the above Depth-First Search algorithm is : Start with the source vertex s Visit one of his neighbours Then visit one neighbour of this neighbour (that was not yet explored) and so on ··· until visiting all reachable vertices from s (when no more neighbors exist backtrack until finding an unexplored path to explore). DFS can also be applied to directed graphs. Here the neighbors of u are taken in the directed sens. DFS
neighbour (that was not yet explored) and so on ··· until visiting all reachable vertices from s (when no more neighbors exist backtrack until finding an unexplored path to explore). DFS can also be applied to directed graphs. Here the neighbors of u are taken in the directed sens. DFS can also be applied to the particular case of trees to do a tree traversal. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 16 / 24 Depth-First Search (DFS) DFS algorithm : P(s) = None, then run visit( s), where the function “visit” is defined recursively as follows : visit(u) : for every v ∈ Adj(u) that does not appear in P : Set P(v) = u and recursively call visit( v). DFS finishes visiting vertex u (for use later !). Remarks : The principle of the above Depth-First Search algorithm is : Start with the source vertex s Visit one of his neighbours Then visit one neighbour of this neighbour (that was not yet explored) and so on ··· until visiting all reachable vertices from s (when no more neighbors exist backtrack until finding an unexplored path to explore). DFS can also be applied to directed graphs. Here the neighbors of u are taken in the directed sens. DFS can also be applied to the particular case of trees to do a tree traversal. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 16 / 24 Depth-First Search (DFS) DFS algorithm : P(s) = None, then run visit( s), where the function “visit” is defined recursively as follows : visit(u) : for every v ∈ Adj(u) that does not appear in P : Set P(v) = u and recursively call visit( v). DFS finishes visiting vertex u (for use later !). Remarks : The principle of the above Depth-First Search algorithm is : Start with the source vertex s Visit one of his neighbours Then visit one neighbour of this neighbour (that was not yet explored) and so on ··· until visiting all reachable vertices from s (when no more neighbors exist backtrack until finding an unexplored path to explore). DFS can also be applied to directed graphs. Here the neighbors of u are taken in the directed sens. DFS can also be applied to the particular case of trees to do a tree traversal. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer
finding an unexplored path to explore). DFS can also be applied to directed graphs. Here the neighbors of u are taken in the directed sens. DFS can also be applied to the particular case of trees to do a tree traversal. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 16 / 24 Depth-First Search (DFS) Example Performing DFS search on the same tree as the example above, starting from the vertex 1, leads to the next traversal of the tree (left), to compare to the previous BFS traversal (right) : Figure – DFS traversal Figure – BFS traversal Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 17 / 24 Depth-First Search (DFS) Proposition DFS visits v and correctly sets P(v) for every vertex v reachable from s. Proof Induction on k, for the result on only vertices within distance k from the source vertex s. Base case ( k = 0) : P(s) is set correctly for s and s is visited. Inductive step : Consider vertex v with d(s, v) = k + 1. Consider vertex u, the second to last vertex on some shortest path from s to v. By induction, since d(s, u) = k, DFS visits u and sets P(u) correctly. While visiting u, DFS considers v ∈ Adj(u). Either v is in P, so has already been visited, or v will be visited while visiting u. In either case, v will be visited by DFS and added correctly to P. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 18 / 24 Depth-First Search (DFS) Proposition DFS visits v and correctly sets P(v) for every vertex v reachable from s. Proof Induction on k, for the result on only vertices within distance k from the source vertex s. Base case ( k = 0) : P(s) is set correctly for s and s is visited. Inductive step : Consider vertex v with d(s, v) = k + 1. Consider vertex u, the second to last vertex on some shortest path from s to v. By induction, since d(s, u) = k, DFS visits u and sets P(u) correctly. While visiting u, DFS considers v ∈ Adj(u). Either v is in P, so has already been visited, or v will be visited while visiting u. In either case, v will be visited by DFS and added correctly to
d(s, u) = k, DFS visits u and sets P(u) correctly. While visiting u, DFS considers v ∈ Adj(u). Either v is in P, so has already been visited, or v will be visited while visiting u. In either case, v will be visited by DFS and added correctly to P. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 18 / 24 Depth-First Search (DFS) Proposition DFS visits v and correctly sets P(v) for every vertex v reachable from s. Proof Induction on k, for the result on only vertices within distance k from the source vertex s. Base case ( k = 0) : P(s) is set correctly for s and s is visited. Inductive step : Consider vertex v with d(s, v) = k + 1. Consider vertex u, the second to last vertex on some shortest path from s to v. By induction, since d(s, u) = k, DFS visits u and sets P(u) correctly. While visiting u, DFS considers v ∈ Adj(u). Either v is in P, so has already been visited, or v will be visited while visiting u. In either case, v will be visited by DFS and added correctly to P. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 18 / 24 Depth-First Search (DFS) Proposition DFS visits v and correctly sets P(v) for every vertex v reachable from s. Proof Induction on k, for the result on only vertices within distance k from the source vertex s. Base case ( k = 0) : P(s) is set correctly for s and s is visited. Inductive step : Consider vertex v with d(s, v) = k + 1. Consider vertex u, the second to last vertex on some shortest path from s to v. By induction, since d(s, u) = k, DFS visits u and sets P(u) correctly. While visiting u, DFS considers v ∈ Adj(u). Either v is in P, so has already been visited, or v will be visited while visiting u. In either case, v will be visited by DFS and added correctly to P. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 18 / 24 Depth-First Search (DFS) Proposition DFS visits v and correctly sets P(v) for every vertex v reachable from s. Proof Induction on k, for the result on only vertices within distance k from the source vertex
P. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 18 / 24 Depth-First Search (DFS) Proposition DFS visits v and correctly sets P(v) for every vertex v reachable from s. Proof Induction on k, for the result on only vertices within distance k from the source vertex s. Base case ( k = 0) : P(s) is set correctly for s and s is visited. Inductive step : Consider vertex v with d(s, v) = k + 1. Consider vertex u, the second to last vertex on some shortest path from s to v. By induction, since d(s, u) = k, DFS visits u and sets P(u) correctly. While visiting u, DFS considers v ∈ Adj(u). Either v is in P, so has already been visited, or v will be visited while visiting u. In either case, v will be visited by DFS and added correctly to P. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 18 / 24 Depth-First Search (DFS) Running time of DFS Algorithm visits each vertex u at most once and spends O(1) time for each v ∈ Adj(u). Total complexity upper bounded by O(1) × P u deg(u) = O(|E|). Unlike BFS, we don’t return a distance for each vertex, so DFS runs in O(|E|) time. Remark :If we want to identify also the vertices that are not reachable from s, i.e. that does not appear in P, the complexity becomes O(|V | + |E|), like BFS. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 19 / 24 Depth-First Search (DFS) Running time of DFS Algorithm visits each vertex u at most once and spends O(1) time for each v ∈ Adj(u). Total complexity upper bounded by O(1) × P u deg(u) = O(|E|). Unlike BFS, we don’t return a distance for each vertex, so DFS runs in O(|E|) time. Remark :If we want to identify also the vertices that are not reachable from s, i.e. that does not appear in P, the complexity becomes O(|V | + |E|), like BFS. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 19 / 24 Depth-First Search (DFS) Running time of DFS Algorithm visits each vertex u at most once and spends O(1) time for each v ∈ Adj(u). Total complexity upper bounded by O(1) × P u deg(u) = O(|E|). Unlike BFS, we don’t return
Algorithmic Foundations (GA) Computer Science School 19 / 24 Depth-First Search (DFS) Running time of DFS Algorithm visits each vertex u at most once and spends O(1) time for each v ∈ Adj(u). Total complexity upper bounded by O(1) × P u deg(u) = O(|E|). Unlike BFS, we don’t return a distance for each vertex, so DFS runs in O(|E|) time. Remark :If we want to identify also the vertices that are not reachable from s, i.e. that does not appear in P, the complexity becomes O(|V | + |E|), like BFS. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 19 / 24 Depth-First Search (DFS) Running time of DFS Algorithm visits each vertex u at most once and spends O(1) time for each v ∈ Adj(u). Total complexity upper bounded by O(1) × P u deg(u) = O(|E|). Unlike BFS, we don’t return a distance for each vertex, so DFS runs in O(|E|) time. Remark :If we want to identify also the vertices that are not reachable from s, i.e. that does not appear in P, the complexity becomes O(|V | + |E|), like BFS. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 19 / 24 Depth-First Search (DFS) Full-BFS and Full-DFS Suppose we want to explore entire graph, not just vertices reachable from one vertex : A simple BFS or DFS from one vertex is not sufficient especially in the case of non connected graph (non strongly connected digraph). Idea :Repeat the graph search algorithm (BFS or DFS) on any unvisited vertex. This unvisited vertex will allow to explore another connected component (or strongly connected component in a digraph). We call this algorithm a Full-BFS or a Full-DFS. Notice that they are providing parent forests instead of parent trees. Remark :A Full-BFS (or a Full-DFS) allows to identify the connected components (or the strongly connected components in a digraph). Complexity :Since we are going through all the vertices, the time complexity of both algorithms Full-BFS and Full-DFS is O(|V | + |E|). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 20 / 24 Depth-First Search (DFS) Full-BFS and Full-DFS Suppose we want to explore entire graph, not just vertices reachable from one vertex : A simple BFS or DFS from one vertex is not sufficient especially in the case of non connected graph (non strongly connected digraph). Idea :Repeat
School 20 / 24 Depth-First Search (DFS) Full-BFS and Full-DFS Suppose we want to explore entire graph, not just vertices reachable from one vertex : A simple BFS or DFS from one vertex is not sufficient especially in the case of non connected graph (non strongly connected digraph). Idea :Repeat the graph search algorithm (BFS or DFS) on any unvisited vertex. This unvisited vertex will allow to explore another connected component (or strongly connected component in a digraph). We call this algorithm a Full-BFS or a Full-DFS. Notice that they are providing parent forests instead of parent trees. Remark :A Full-BFS (or a Full-DFS) allows to identify the connected components (or the strongly connected components in a digraph). Complexity :Since we are going through all the vertices, the time complexity of both algorithms Full-BFS and Full-DFS is O(|V | + |E|). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 20 / 24 Depth-First Search (DFS) Full-BFS and Full-DFS Suppose we want to explore entire graph, not just vertices reachable from one vertex : A simple BFS or DFS from one vertex is not sufficient especially in the case of non connected graph (non strongly connected digraph). Idea :Repeat the graph search algorithm (BFS or DFS) on any unvisited vertex. This unvisited vertex will allow to explore another connected component (or strongly connected component in a digraph). We call this algorithm a Full-BFS or a Full-DFS. Notice that they are providing parent forests instead of parent trees. Remark :A Full-BFS (or a Full-DFS) allows to identify the connected components (or the strongly connected components in a digraph). Complexity :Since we are going through all the vertices, the time complexity of both algorithms Full-BFS and Full-DFS is O(|V | + |E|). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 20 / 24 Depth-First Search (DFS) Application : Topological Sort Definition A Directed Acyclic Graph(DAG) is a directed graph that contains no directed cycles. A Topological Orderof a graph G = (V , E) is an ordering f on the vertices such that : every edge ( u, v) ∈ E satisfies f (u) < f (v). Recall (ES4 - ex7) : A directed graph admits a topological ordering if and only if it is a DAG. Question : How to find a topological order ? Definition A Finishing Orderis the order in which a Full-DFS finishes
u, v) ∈ E satisfies f (u) < f (v). Recall (ES4 - ex7) : A directed graph admits a topological ordering if and only if it is a DAG. Question : How to find a topological order ? Definition A Finishing Orderis the order in which a Full-DFS finishes visiting each vertex in G. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 21 / 24 Depth-First Search (DFS) Application : Topological Sort Definition A Directed Acyclic Graph(DAG) is a directed graph that contains no directed cycles. A Topological Orderof a graph G = (V , E) is an ordering f on the vertices such that : every edge ( u, v) ∈ E satisfies f (u) < f (v). Recall (ES4 - ex7) : A directed graph admits a topological ordering if and only if it is a DAG. Question : How to find a topological order ? Definition A Finishing Orderis the order in which a Full-DFS finishes visiting each vertex in G. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 21 / 24 Depth-First Search (DFS) Application : Topological Sort Definition A Directed Acyclic Graph(DAG) is a directed graph that contains no directed cycles. A Topological Orderof a graph G = (V , E) is an ordering f on the vertices such that : every edge ( u, v) ∈ E satisfies f (u) < f (v). Recall (ES4 - ex7) : A directed graph admits a topological ordering if and only if it is a DAG. Question : How to find a topological order ? Definition A Finishing Orderis the order in which a Full-DFS finishes visiting each vertex in G. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 21 / 24 Depth-First Search (DFS) Application : Topological Sort Proposition A digraph G = (V , E) is a DAG if and only if the reverse of a finishing order of a Full-DFS is a topological order. Proof ⇐) This implication is trivial. ⇒) Need to prove, for every edge ( u, v) ∈ E that u is ordered before v, i.e. that the visit to v finishes before the visit to u finishes. Two cases : If u is visited before v : Before visit to u finishes, will visit v (via (u, v) or otherwise). Thus the visit to v finishes before finishing the visit
is ordered before v, i.e. that the visit to v finishes before the visit to u finishes. Two cases : If u is visited before v : Before visit to u finishes, will visit v (via (u, v) or otherwise). Thus the visit to v finishes before finishing the visit to u. If v is visited before u : u can’t be reached from v since graph is acyclic. Thus the visit to v finishes before visiting u. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 22 / 24 Depth-First Search (DFS) Application : Cycle detection Full-DFS will find a topological order iff the graph G = (V , E) is acyclic. If G contains a cycle then reverse finishing order for Full-DFS (called f ) is not a topological order. Meaning that there exists ( u, v) ∈ E such that Full-DFS finishes visiting u before it finishes visiting v (i.e. f (v) < f (u)). Proposition Let G be a diagraph that contains a cycle, and ( u, v) ∈ E such that Full-DFS finishes visiting u before it finishes visiting v, then this Full-DFS contains a path from v to u constructed by considering the reversed path back to s from vertex v. Adding the edge ( u, v) to this path we obtain a cycle. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 23 / 24 Depth-First Search (DFS) Application : Cycle detection Proof (of Prop.) Necessarily v is visited before u (because otherwise using the edge ( u, v), v will be visited and finished before u). Since Full-DFS finishes visiting u before v this means that during the visit of v, Full-DFS starts and finishes the visit of u, and this means that v is an ancestor of u, giving a path from v to u. Complexity :We need to run Full-DFS needing O(|V | + |E|). Then, we need to find an edge ( u, v) such that f (v) < f (u) and this will take O(|E|) to go through all the edges. Finally we need to go through the reverse path from v to u, and this will need at most O(|V |). Finally, the total complexity is O(|V | + |E|). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 24 / 24
to go through the reverse path from v to u, and this will need at most O(|V |). Finally, the total complexity is O(|V | + |E|). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 24 / 24
Chapter 7 : Shortest Path Problem - Dijkstra’s Algorithm Omar Saadi omar.saadi@um6p.ma UM6P - College of Computing 1st year of the engineering degree of UM6P-CS Academic year 2024-2025 Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 1 / 12 Outline 1 Introduction 2 Dijkstra’s Algorithm Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 2 / 12 Introduction Outline 1 Introduction 2 Dijkstra’s Algorithm Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 3 / 12 Introduction Shortest path problem Some real-world problems : How can you find the shortest routes from your home to every place in town ? How to find the cheapest flight(s) from Casablanca to Hong Kong allowing stopovers ? How to find the fastest driving route (Google Maps) ? The internet : how to find the fastest path to send information through a network of routers ? All these problems can be modeled using weighted (di)graphs, and solving the shortest path problem. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 4 / 12 Introduction Framework We have a graph (or digraph) G = (V , E). Each edge ( u, v) ∈ E has a nonnegative weight w(u, v) (that represents a distance, a cost, a time, ...). We have a starting vertex s and a destination vertex d. Shortest path problem We want to solve the following problem : minimize P a s,d-path in G w(P), where w(P) is the weight of the path P given as the sum of the weights of the edges forming it. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 5 / 12 Dijkstra’s Algorithm Outline 1 Introduction 2 Dijkstra’s Algorithm Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 6 / 12 Dijkstra’s Algorithm Dijkstra’s Algorithm Input :A graph (or digraph) with nonnegative edge weights and a starting vertex s. Output :Distance d(s, t) from s to each other vertex t and a shortest path tree given by identifying the parent P(u) of each vertex u. Key idea :∀t ∈ V , the algorithm computes an estimate d[t] of the distance of t from the source s such that : 1 At any point in time, d[t] ≥ d(s, t), and 2 when t is finished, d[t] = d(s, t). Let w(x, y) = +∞ if (x,
idea :∀t ∈ V , the algorithm computes an estimate d[t] of the distance of t from the source s such that : 1 At any point in time, d[t] ≥ d(s, t), and 2 when t is finished, d[t] = d(s, t). Let w(x, y) = +∞ if (x, y) is not an edge. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 7 / 12 Dijkstra’s Algorithm Dijkstra’s Algorithm Idea : Maintain the set S of vertices to which a shortest path from s is known, enlarging S to include all vertices. To do this, maintain a tentative distance d[t] from s to each t ̸∈ S, being the length of the shortest s, t-path yet found. Initialization :Set S = {s}; d[s] = 0; P(s) = None. For t ̸= s, set d[t] = w(s, t) and if w(s, t) ̸= +∞ then take P(t) = s. Iteration :Select a vertex x ̸∈ S such that d[x] = mint̸∈S d[t]. Add the vertex x to S. For each edge ( x, y) ∈ E such that y ̸∈ S : update d[y] to min{d[y], d[x] + w(x, y)}. If d[y] changes, then update P(y) to x. The iteration continues until S = V (G) or until d[y] = +∞ for every y ̸∈ S. At the end, set d(s, x) = d[x] for all x ∈ V . Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 8 / 12 Dijkstra’s Algorithm Lemma 1 For every u, at any point of time d[u] ≥ d(s, u) and d[u] represents the length of some path from s to u. Proof We proceed by induction over the iterations of the algorithm. Base case :we know that d[s] = 0 = d(s, s) and for each vertex t ̸= s we have d[t] = w(s, t) ≥ d(s, t), so we know that the claim holds initially. Induction :when d[u] is changed to d[x] + w(x, u) then (by the induction hypothesis) there is a path from s to x of weight d[x] (that does not contain u) and an edge ( x, u) of weight w(x, u). This means there is a path from s to u of weight d[u] = d[x] + w(x, u). This implies that d[u] is at least the weight of the shortest path = d(s, u). Omar Saadi
does not contain u) and an edge ( x, u) of weight w(x, u). This means there is a path from s to u of weight d[u] = d[x] + w(x, u). This implies that d[u] is at least the weight of the shortest path = d(s, u). Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 9 / 12 Dijkstra’s Algorithm Lemma 2 The assertion d[x] ≤ d[y] for all y ̸∈ S stays true at all points after x is inserted into S. Proof We take F = V \ S. By absurd, assume that at some point for some y ∈ F we get d[y] < d[x] and let y be the first such y. Before d[y] was updated d [y′] ≥ d[x] for all y′ ∈ F . But then when d[y] was changed, it was due to some neighbor y′ of y in F , such that d[y] = d [y′] + w(y′, y) ≥ d [y′] ≥ d[x], so we get a contradiction. Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 10 / 12 Dijkstra’s Algorithm Proposition When vertex x is placed in S, d[x] = d(s, x), and backtracking from x to s using the parent list P yields a shortest path from s to x. Proof We take F = V \ S. We do an induction on the order of placement of vertices into S. For the base case, s is placed into S where d[s] = d(s, s) = 0 and P(s) = None, so initially, the claim holds. Inductive step :we assume that for all vertices y currently in S, d[y] = d(s, y) and P yields shortest paths for them. Let x be the vertex that will be added to S, i.e. satisfying d[x] = mint̸∈S d[t]. Let p be a shortest path from s to x. Suppose z is the vertex on p closest to x for which d[z] = d(s, z). We know z exists since there is at least one such vertex, namely s, where d[s] = d(s, s). By the choice of z, for every vertex y on p between z (not inclusive) to x (inclusive), d[y] > d(s, y). Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 11 / 12 Dijkstra’s Algorithm Proof (Cont.) We have the following two options for z
s). By the choice of z, for every vertex y on p between z (not inclusive) to x (inclusive), d[y] > d(s, y). Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 11 / 12 Dijkstra’s Algorithm Proof (Cont.) We have the following two options for z : 1 If z = x, then d[x] = d(s, x) and we are done. 2 Suppose z ̸= x. Then there is a vertex z′ after z on p. We know that d[z] = d(s, z) ≤ d(s, x) ≤ d[x]. Finally, towards a contradiction, suppose d[z] < d[x]. By the choice of x ∈ F we know d[x] = mint∈F d[t]. Thus, since d[z] < d[x], we know z ∈ S. This means the edges out of z, and in particular ( z, z′), were already considered by our algorithm. But this means that d [z′] ≤ d(s, z) + w (z, z′) = d (s, z′), because z is on the shortest path from s to z′. However, this contradicts z being the closest vertex on p to x meeting the criteria d[z] = d(s, z). Thus, the assumption d[z] < d[x] is false and d[x] must equal d(s, x). Note that updating the parent P(y) whenever d[y] is improved insures that at the end P contains the parents in shortest paths with lengths d[x] = d(s, x) for all x ∈ V . Omar Saadi (College of Computing) Algorithmic Foundations 3 (GA) Computer Science School 12 / 12
Chapter 8 : Shortest Path Problem - Bellman-Ford Algorithm Omar Saadi omar.saadi@um6p.ma UM6P - College of Computing 1st year of the engineering degree of UM6P-CS Academic year 2024-2025 Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 1 / 13 Outline 1 Introduction 2 Bellman-Ford Algorithm Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 2 / 13 Introduction Outline 1 Introduction 2 Bellman-Ford Algorithm Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 3 / 13 Introduction Framework Definition A negative cycleon a graph (or digraph) is a cycle such that the sum of the weights of its edges is negative (i.e. < 0). We have a graph (or digraph) G = (V , E). Each edge ( u, v) ∈ E has a weight w(u, v) (that can be negative), but G has no negative cycles. We have a starting vertex s and a destination vertex d. We want to solve the shortest path problem : minimize P a s,d-path in G w(P), where w(P) is the weight of the path P given as the sum of the weights of the edges forming it. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 4 / 13 Bellman-Ford Algorithm Outline 1 Introduction 2 Bellman-Ford Algorithm Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 5 / 13 Bellman-Ford Algorithm Bellman-Ford Algorithm Input :A graph (or digraph) with no negative cycles and a starting vertex s. Output :Distance d(s, u) from s to each other vertex u and a shortest path tree given by identifying the parent P(u) of each vertex u. Key idea :∀u ∈ V , the algorithm computes an estimate d[u] of the distance of u from the source s such that : At iteration k, d[u] is the length of a path from s to u. The estimate d[u] is non-increasing and it is updated in a dynamic programming way (a step by step way). At the last iteration n − 1, d[u] will contain d(s, u). Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 6 / 13 Bellman-Ford Algorithm Bellman-Ford Algorithm Initialization :Set d[s] = 0; P(s) = None. For u ̸= s, set d[u] = +∞ and P(u) = None. Iteration : for i from 1 to n − 1 do : for (u, v) ∈ E do : d[v] =
Science School 6 / 13 Bellman-Ford Algorithm Bellman-Ford Algorithm Initialization :Set d[s] = 0; P(s) = None. For u ̸= s, set d[u] = +∞ and P(u) = None. Iteration : for i from 1 to n − 1 do : for (u, v) ∈ E do : d[v] = min{d[v], d[u] + w(u, v)}, and if d[v] changes then P[v] = u. for (u, v) ∈ E do : if d[v] > d[u] + w(u, v) then return “A negative cycle exists” Return d[u] and P[u] for all u ∈ V . Remark :The order in which the edges are considered impacts the execution of the algorithm. A possible order of edges is to order the vertices and then take the outgoing edges of each one of them. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 7 / 13 Bellman-Ford Algorithm Bellman-Ford detects negative cycles Proposition If there is a negative cycle reachable from the source s, then at the end we will have for some edge ( u, v) ∈ E, d(v) > d(u) + w(u, v). Proof Suppose v0 → v1 → ··· →vk is a negative cycle reachable from s, where v0 = vk , i.e. Pk i=1 w (vi−1, vi ) < 0. By absurd, suppose that at the end we have d(vi ) ≤ d(vi−1) + w(vi−1, vi ) for all i = 1, . . . ,k. Then taking the sum, we getPk i=1 d (vi ) ≤ Pk i=1 d (vi−1) + Pk i=1 w (vi−1, vi ). Observing that the first two terms are the same (because v0 = vk ), we deduce that : kX i=1 w (vi−1, vi ) ≥ 0. (which is absurd) Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 8 / 13 Bellman-Ford Algorithm To prove correctness of the distance estimates (at the end), we reformulate the algorithm in a dynamic programming way. This formulation is useful for the proof but not for space (and time) complexity : Bellman-Ford Algorithm (Variant 1) Initialization :For all k ∈ {0, ··· , n − 1}, set dk [s] = 0; Pk (s) = None and for all u ̸= s, set dk [u] = +∞ and Pk (u) = None. Iteration : for k from 1 to n − 1 do : for (u, v) ∈ E do* : dk [v] =
n − 1}, set dk [s] = 0; Pk (s) = None and for all u ̸= s, set dk [u] = +∞ and Pk (u) = None. Iteration : for k from 1 to n − 1 do : for (u, v) ∈ E do* : dk [v] = min{dk−1[v], dk−1[u] + w(u, v), dk [v]}, and if dk [v] changes to dk−1[v] then Pk [v] = Pk−1[v], and if dk [v] changes to dk−1[u] + w(u, v) then Pk [v] = u. for (u, v) ∈ E do : if dn−1[v] > dn−1[u] + w(u, v) then return “A negative cycle exists” Return dn−1[u] and Pn−1[u] for all u ∈ V . *Note that this variant 1 of the algorithm is slower (and takes more storage space). Indeed, to have the same iteration as the original version we need to take dk [v] = min{dk−1[v], dk−1[u] + w(u, v), dk [v], dk [u] + w(u, v)}. ⇒ Proving that this variant 1 is correct proves the original version is correct too. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 9 / 13 Bellman-Ford Algorithm Proposition If the graph G has no negative cycles, then dn−1[v] = d(s, v) for all vertices v, and backtracking from v to s using the parent list Pn−1 yields a shortest path from s to v. Proof By induction on k, we will prove that dk [v] is the minimum weight of a path from s to v that uses ≤ k edges. This will show that dn−1[v] is the distance from s to v because there is no negative cycles in the graph (a shortest path contains at most n − 1 edges). Base case :If k = 0, then dk [v] = 0 for v = s, and + ∞ otherwise. So the claim is satisfied. Inductive step :Suppose that for all vertices u, dk−1[u] is the minimum weight of a path from s to u that uses ≤ k − 1 edges. If v ̸= s, let P be a shortest simple path from s to v with ≤ k edges, and let u be the node just before v on P. Let Q be the path from s to u. Then Q is a shortest path from s to u that uses at most k − 1 edges. By the inductive hypothesis, w(Q) = dk−1[u]. Omar
with ≤ k edges, and let u be the node just before v on P. Let Q be the path from s to u. Then Q is a shortest path from s to u that uses at most k − 1 edges. By the inductive hypothesis, w(Q) = dk−1[u]. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 10 / 13 Bellman-Ford Algorithm Proof (Cont.) In iteration k, we update dk [v] = min (dk−1[v], dk−1[u] + w(u, v)). We know that dk [v] ≤ dk−1[u] + w(u, v) = w(Q) + w(u, v) = w(P), i.e. dk [v] ≤ w(P). Furthermore, dk [v] is the length of a path from s to v with at most k edges, which must be at least as large as w(P). Therefore, dk [v] = w(P) is the minimum weight of a path from s to v that uses at most k edges. Note that the update of the parents Pk (y) insures that the parent list Pk contains the parents in the shortest paths using at most k edges. So that, Pn−1 contains the parents in the shortest paths from s to v for every v ∈ V . Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 11 / 13 Bellman-Ford Algorithm Complexity Time complexity :We have the n − 1 iterations and in each iteration we go through all the edges in our graph. For each edge ( u, v) ∈ E, we do O(1) operations. Therefore the time complexity of the algorithm is : O(|V ||E|). Space complexity :The algorithm (in its original version) uses only the two lists d and P. Therefore, the space complexity is O(|V |). Remark :If at a given iteration k no distance d[u] is changed, then the algorithm can be stopped and the distance and shortest paths are found. Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 12 / 13 Bellman-Ford Algorithm Example In the following digraph, find the distances from vertex A to all the other vertices and the list of parents providing the shortest paths. A B C D E F G H 2 4 −1 4 5 −3 1 2 2 3−2 2 −3 Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 13 / 13
paths. A B C D E F G H 2 4 −1 4 5 −3 1 2 2 3−2 2 −3 Omar Saadi (College of Computing) Algorithmic Foundations 3 Computer Science School 13 / 13
Chapter 9 : Shortest Path Problem (Floyd-Warshall Algorithm) and Transitive Closure (Warshall’s Algorithm) Omar Saadi omar.saadi@um6p.ma UM6P - College of Computing 1st year of the engineering degree of UM6P-CS Academic year 2024-2025 Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 1 / 18 Outline 1 Introduction 2 Floyd-Warshall Algorithm 3 Transitive Closure Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 2 / 18 Introduction Outline 1 Introduction 2 Floyd-Warshall Algorithm 3 Transitive Closure Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 3 / 18 Introduction Framework We have a digraph (or graph) G = (V , E). Each edge ( u, v) ∈ E has a weight w(u, v) (that can be negative), but G has no negative cycles. All Pairs Shortest Path problem For each pair of vertices s, t, we want to solve the problem : minimize P a s,t-path in G w(P), where w(P) is the weight of the path P given as the sum of the weights of the edges forming it. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 4 / 18 Floyd-Warshall Algorithm Outline 1 Introduction 2 Floyd-Warshall Algorithm 3 Transitive Closure Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 5 / 18 Floyd-Warshall Algorithm Floyd-Warshall Algorithm Input :A digraph (or graph) G = (V , E) with |V | = n vertices. Output :(If there is no negative cycles)Distance d(s, t) from each vertex s to each vertex t and a shortest path tree (from each starting vertex s) given by identifying the parent P(s, t) of each vertex t in the shortest path from s to t. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 6 / 18 Floyd-Warshall Algorithm Floyd-Warshall Algorithm Key ideas : The vertices of the digraph are identified with the integers from 1 to n (i.e. V = {1, ··· , n}). If k is the biggest vertex appearing on an s, t-shortest path, then d(s, t) = d(s, k) + d(k, t) and moreover, the sub-paths from s to k and from k to t only use vertices up to k − 1 internally. For each k going from 1 to n, we consider the problem of computing dk (s, t) which is the smallest weight of an s, t-path that only uses vertices 1, ··· , k internally.
k and from k to t only use vertices up to k − 1 internally. For each k going from 1 to n, we consider the problem of computing dk (s, t) which is the smallest weight of an s, t-path that only uses vertices 1, ··· , k internally. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 7 / 18 Floyd-Warshall Algorithm Floyd-Warshall Algorithm Floyd-Warshall Algorithm Initialization : ∀u ∈ V , ∀k ∈ {0, ··· , n}, dk (u, u) = 0, Pk (u, u) = None ∀u, v ∈ V , u ̸= v, ∀k ∈ {1, ··· , n}, dk (u, v) = +∞, Pk (u, v) = None ∀(u, v) ∈ E, d0(u, v) = w(u, v), P0(u, v) = u ∀(u, v) ̸∈ E, d0(u, v) = +∞, P0(u, v) = None Iterations : for k from 1 to n do : for (u, v) ∈ V × V do : if dk−1(u, k) + dk−1(k, v) < dk−1(u, v) then dk (u, v) = dk−1(u, k) + dk−1(k, v) and Pk (u, v) = Pk−1(k, v), else dk (u, v) = dk−1(u, v) and Pk (u, v) = Pk−1(u, v). Return dn(u, v) and Pn(u, v) for all ( u, v) ∈ V × V . Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 8 / 18 Floyd-Warshall Algorithm Correctness Proposition If the digraph G has no negative cycles, then dn(s, t) = d(s, t) for all couple of vertices ( s, t), and backtracking from t to s using the parent list Pn yields a shortest path from s to t. Proof We prove by induction over k ∈ {0, ··· , n}, that dk (s, t) is the minimal length of a path from s to t which is allowed to use internally only the vertices smaller of equal to k. Base case :For k = 0, we initialize each d0(u, v) as the edge weight w(u, v) if ( u, v) ∈ E, else we set it to + ∞, so that d0(u, v) is exactly the length of a shortest path from s to t that don’t use any other vertex internally. P0(u, v) is also properly initialized. Inductive step :Let k ∈ {1, ··· , n} and suppose that the property is true up to k − 1. Omar Saadi (College of
is exactly the length of a shortest path from s to t that don’t use any other vertex internally. P0(u, v) is also properly initialized. Inductive step :Let k ∈ {1, ··· , n} and suppose that the property is true up to k − 1. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 9 / 18 Floyd-Warshall Algorithm Proof (Cont.) Let P be a shortest path from u to v using 1, ··· , k as intermediate vertices. We can assume that P is a simple path (since there are no negative cycles). There are two cases : 1 P contains k : In this case, we know that neither the path from u to k nor the path from k to v contains any vertices that are greater than k − 1. Then, by the induction hypothesis we get dk−1(u, k) + dk−1(k, v) = w(P) ≤ dk−1(u, v). Therefore, in the algorithm, dk (u, v) = dk−1(u, k) + dk−1(k, v) = w(P) and Pk (u, v) = Pk−1(k, v) is the predecessor of v in a shortest path from u to v using only vertices between 1 and k internally. 2 P does not contain k : In this case P uses only vertices between 1 and k − 1, then w(P) = dk−1(u, v) ≤ dk−1(u, k) + dk−1(k, v). Therefore, from the algorithm, dk (u, v) = dk−1(u, v) = w(P) and Pk (u, v) = Pk−1(u, v) is an adequate update of the predecessor of v. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 10 / 18 Floyd-Warshall Algorithm Detection of negative cycles Proposition The digraph contains a negative cycle if and only if Floyd-Warshall algorithm returns dn such that dn(u, u) < 0 for some vertex u. Proof If there is a cycle C from u to u of negative weight, then dn(u, u) will be at most the weight of this cycle C, and hence, will be negative. Otherwise, and since d0(u, u) = 0 in the beginning of the algorithm, no update can cause dn(u, u) to become negative. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 11 / 18 Floyd-Warshall Algorithm Complexity Time Complexity :The runtime of the Floyd-Warshall algorithm is proportional to the size of the table {dk (u, v)}(k,u,v)∈V 3 (which is the same size of the table
dn(u, u) to become negative. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 11 / 18 Floyd-Warshall Algorithm Complexity Time Complexity :The runtime of the Floyd-Warshall algorithm is proportional to the size of the table {dk (u, v)}(k,u,v)∈V 3 (which is the same size of the table of predecessors {Pk (u, v)}(k,u,v)∈V 3 ). Indeed, filling each entry of the table d (and also of P) only depends on at most two other entries filled in before it. Therefore, the time complexity is : O   |V |3 . Space Complexity :Note that we can choose to store only the table of the current iteration ( dk (u, v), ∀(u, v) ∈ V 2) and the one of the previous iteration (dk−1(u, v), ∀(u, v) ∈ V 2) instead of storing all the tables dk , ∀k ∈ {0, ··· , n}. Therefore, the space complexity is : O   |V |2 . Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 12 / 18 Floyd-Warshall Algorithm Example In the following digraph, use Floyd-Warshall algorithm to find the distances between all pairs of vertices and the list of parents providing the shortest paths rooted at each vertex. A B CD 3 5 4 −2 1 3 2 −1 Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 13 / 18 Transitive Closure Outline 1 Introduction 2 Floyd-Warshall Algorithm 3 Transitive Closure Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 14 / 18 Transitive Closure Transitive Closure of a digraph Definition 1 Given a digraph G = (V , E), we call the transitive closureof G, the subset T of V × V such that for all ( u, v) ∈ V × V , (u, v) ∈ T if and only if there is a path from u to v in G. Definition 2 A digraph G is transitive if it satisfies : for all vertices u, v, w, if (u, v) ∈ E and (v, w) ∈ E then (u, w) ∈ E. Lemma The transitive closure T of a graph G gives the smallest set of edges that needs to be added to make the graph G transitive. Proof Remark that if a path from u to v exists in G then necessarily the edge (u, v) needs to be added to G to make it transitive and
a graph G gives the smallest set of edges that needs to be added to make the graph G transitive. Proof Remark that if a path from u to v exists in G then necessarily the edge (u, v) needs to be added to G to make it transitive and that adding all such edges suffices to make the digraph transitive. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 15 / 18 Transitive Closure Warshall’s Algorithm Input :A digraph G = (V , E) with |V | = n vertices. Output :The set T of couples ( u, v) ∈ V × V , such that there exists a path from u to v in the graph G. Key ideas :Similar procedure as Floyd-Warshall algorithm. The vertices of the digraph are identified with the integers from 1 to n (i.e. V = {1, ··· , n}). If (u, v) ∈ T and k is the biggest vertex appearing on an u, v-path, then (u, k) ∈ T and (k, v) ∈ T and moreover, the sub-paths from u to k and from k to v only use vertices up to k − 1 internally. For each k going from 1 to n, we consider the problem of identifying if there is a u,v-path that only uses vertices 1 , ··· , k internally. If such path exists we put ck (u, v) = 1, otherwise we put ck (u, v) = 0. Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 16 / 18 Transitive Closure Warshall’s Algorithm Initialization : ∀u, v ∈ V , ∀k ∈ {1, ··· , n}, ck (u, v) = 0 ∀(u, v) ∈ E, c0(u, v) = 1 ∀(u, v) ̸∈ E, c0(u, v) = 0 Iterations : for k from 1 to n do : for (u, v) ∈ V × V do* : if ck−1(u, v) = 1 or ( ck−1(u, k) = 1 and ck−1(k, v) = 1) then ck (u, v) = 1, Return cn(u, v) for all ( u, v) ∈ V × V . * : This is similar to writing the following (with boolean variables) : ck (u, v) = ck−1(u, v) or  ck−1(u, k) and ck−1(k, v)  . Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 17 / 18 Transitive Closure Correctness and complexity of Warshall’s
. * : This is similar to writing the following (with boolean variables) : ck (u, v) = ck−1(u, v) or  ck−1(u, k) and ck−1(k, v)  . Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 17 / 18 Transitive Closure Correctness and complexity of Warshall’s algorithm Proposition For all ( u, v) ∈ V × V , we have cn(u, v) = 1 if and only if there exists a path from u to v in the digraph G, i.e. T = {(u, v) ∈ V 2 | cn(u, v) = 1}. Proof : Similar to the proof for Floyd-Warshall algorithm. Similar to Floyd-Warshall algorithm, we have the following complexities for Warshall’s algorithm : Time Complexity :O(|V |3). Space Complexity :O(|V |2). Omar Saadi (College of Computing) Algorithmic Foundations (GA) Computer Science School 18 / 18
